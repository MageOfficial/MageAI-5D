(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Chess = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*
 * JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/* global define */

/* eslint-disable strict */

;(function ($) {
  'use strict'

  /**
   * Add integers, wrapping at 2^32.
   * This uses 16-bit operations internally to work around bugs in interpreters.
   *
   * @param {number} x First integer
   * @param {number} y Second integer
   * @returns {number} Sum
   */
  function safeAdd(x, y) {
    var lsw = (x & 0xffff) + (y & 0xffff)
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16)
    return (msw << 16) | (lsw & 0xffff)
  }

  /**
   * Bitwise rotate a 32-bit number to the left.
   *
   * @param {number} num 32-bit number
   * @param {number} cnt Rotation count
   * @returns {number} Rotated number
   */
  function bitRotateLeft(num, cnt) {
    return (num << cnt) | (num >>> (32 - cnt))
  }

  /**
   * Basic operation the algorithm uses.
   *
   * @param {number} q q
   * @param {number} a a
   * @param {number} b b
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */
  function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)
  }
  /**
   * Basic operation the algorithm uses.
   *
   * @param {number} a a
   * @param {number} b b
   * @param {number} c c
   * @param {number} d d
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */
  function md5ff(a, b, c, d, x, s, t) {
    return md5cmn((b & c) | (~b & d), a, b, x, s, t)
  }
  /**
   * Basic operation the algorithm uses.
   *
   * @param {number} a a
   * @param {number} b b
   * @param {number} c c
   * @param {number} d d
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */
  function md5gg(a, b, c, d, x, s, t) {
    return md5cmn((b & d) | (c & ~d), a, b, x, s, t)
  }
  /**
   * Basic operation the algorithm uses.
   *
   * @param {number} a a
   * @param {number} b b
   * @param {number} c c
   * @param {number} d d
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */
  function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t)
  }
  /**
   * Basic operation the algorithm uses.
   *
   * @param {number} a a
   * @param {number} b b
   * @param {number} c c
   * @param {number} d d
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */
  function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t)
  }

  /**
   * Calculate the MD5 of an array of little-endian words, and a bit length.
   *
   * @param {Array} x Array of little-endian words
   * @param {number} len Bit length
   * @returns {Array<number>} MD5 Array
   */
  function binlMD5(x, len) {
    /* append padding */
    x[len >> 5] |= 0x80 << len % 32
    x[(((len + 64) >>> 9) << 4) + 14] = len

    var i
    var olda
    var oldb
    var oldc
    var oldd
    var a = 1732584193
    var b = -271733879
    var c = -1732584194
    var d = 271733878

    for (i = 0; i < x.length; i += 16) {
      olda = a
      oldb = b
      oldc = c
      oldd = d

      a = md5ff(a, b, c, d, x[i], 7, -680876936)
      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586)
      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819)
      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330)
      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897)
      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426)
      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341)
      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983)
      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416)
      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417)
      c = md5ff(c, d, a, b, x[i + 10], 17, -42063)
      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162)
      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682)
      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101)
      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290)
      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329)

      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510)
      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632)
      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713)
      b = md5gg(b, c, d, a, x[i], 20, -373897302)
      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691)
      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083)
      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335)
      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848)
      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438)
      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690)
      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961)
      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501)
      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467)
      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784)
      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473)
      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734)

      a = md5hh(a, b, c, d, x[i + 5], 4, -378558)
      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463)
      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562)
      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556)
      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060)
      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353)
      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632)
      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640)
      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174)
      d = md5hh(d, a, b, c, x[i], 11, -358537222)
      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979)
      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189)
      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487)
      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835)
      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520)
      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651)

      a = md5ii(a, b, c, d, x[i], 6, -198630844)
      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415)
      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905)
      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055)
      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571)
      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606)
      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523)
      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799)
      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359)
      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744)
      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380)
      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649)
      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070)
      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379)
      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259)
      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551)

      a = safeAdd(a, olda)
      b = safeAdd(b, oldb)
      c = safeAdd(c, oldc)
      d = safeAdd(d, oldd)
    }
    return [a, b, c, d]
  }

  /**
   * Convert an array of little-endian words to a string
   *
   * @param {Array<number>} input MD5 Array
   * @returns {string} MD5 string
   */
  function binl2rstr(input) {
    var i
    var output = ''
    var length32 = input.length * 32
    for (i = 0; i < length32; i += 8) {
      output += String.fromCharCode((input[i >> 5] >>> i % 32) & 0xff)
    }
    return output
  }

  /**
   * Convert a raw string to an array of little-endian words
   * Characters >255 have their high-byte silently ignored.
   *
   * @param {string} input Raw input string
   * @returns {Array<number>} Array of little-endian words
   */
  function rstr2binl(input) {
    var i
    var output = []
    output[(input.length >> 2) - 1] = undefined
    for (i = 0; i < output.length; i += 1) {
      output[i] = 0
    }
    var length8 = input.length * 8
    for (i = 0; i < length8; i += 8) {
      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32
    }
    return output
  }

  /**
   * Calculate the MD5 of a raw string
   *
   * @param {string} s Input string
   * @returns {string} Raw MD5 string
   */
  function rstrMD5(s) {
    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8))
  }

  /**
   * Calculates the HMAC-MD5 of a key and some data (raw strings)
   *
   * @param {string} key HMAC key
   * @param {string} data Raw input string
   * @returns {string} Raw MD5 string
   */
  function rstrHMACMD5(key, data) {
    var i
    var bkey = rstr2binl(key)
    var ipad = []
    var opad = []
    var hash
    ipad[15] = opad[15] = undefined
    if (bkey.length > 16) {
      bkey = binlMD5(bkey, key.length * 8)
    }
    for (i = 0; i < 16; i += 1) {
      ipad[i] = bkey[i] ^ 0x36363636
      opad[i] = bkey[i] ^ 0x5c5c5c5c
    }
    hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)
    return binl2rstr(binlMD5(opad.concat(hash), 512 + 128))
  }

  /**
   * Convert a raw string to a hex string
   *
   * @param {string} input Raw input string
   * @returns {string} Hex encoded string
   */
  function rstr2hex(input) {
    var hexTab = '0123456789abcdef'
    var output = ''
    var x
    var i
    for (i = 0; i < input.length; i += 1) {
      x = input.charCodeAt(i)
      output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f)
    }
    return output
  }

  /**
   * Encode a string as UTF-8
   *
   * @param {string} input Input string
   * @returns {string} UTF8 string
   */
  function str2rstrUTF8(input) {
    return unescape(encodeURIComponent(input))
  }

  /**
   * Encodes input string as raw MD5 string
   *
   * @param {string} s Input string
   * @returns {string} Raw MD5 string
   */
  function rawMD5(s) {
    return rstrMD5(str2rstrUTF8(s))
  }
  /**
   * Encodes input string as Hex encoded string
   *
   * @param {string} s Input string
   * @returns {string} Hex encoded string
   */
  function hexMD5(s) {
    return rstr2hex(rawMD5(s))
  }
  /**
   * Calculates the raw HMAC-MD5 for the given key and data
   *
   * @param {string} k HMAC key
   * @param {string} d Input string
   * @returns {string} Raw MD5 string
   */
  function rawHMACMD5(k, d) {
    return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d))
  }
  /**
   * Calculates the Hex encoded HMAC-MD5 for the given key and data
   *
   * @param {string} k HMAC key
   * @param {string} d Input string
   * @returns {string} Raw MD5 string
   */
  function hexHMACMD5(k, d) {
    return rstr2hex(rawHMACMD5(k, d))
  }

  /**
   * Calculates MD5 value for a given string.
   * If a key is provided, calculates the HMAC-MD5 value.
   * Returns a Hex encoded string unless the raw argument is given.
   *
   * @param {string} string Input string
   * @param {string} [key] HMAC key
   * @param {boolean} [raw] Raw output switch
   * @returns {string} MD5 output
   */
  function md5(string, key, raw) {
    if (!key) {
      if (!raw) {
        return hexMD5(string)
      }
      return rawMD5(string)
    }
    if (!raw) {
      return hexHMACMD5(key, string)
    }
    return rawHMACMD5(key, string)
  }

  if (typeof define === 'function' && define.amd) {
    define(function () {
      return md5
    })
  } else if (typeof module === 'object' && module.exports) {
    module.exports = md5
  } else {
    $.md5 = md5
  }
})(this)

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
(function (global){(function (){
var performance = global.performance || {};

var present = (function () {
  var names = ['now', 'webkitNow', 'msNow', 'mozNow', 'oNow'];
  while (names.length) {
    var name = names.shift();
    if (name in performance) {
      return performance[name].bind(performance);
    }
  }

  var dateNow = Date.now || function () { return new Date().getTime(); };
  var navigationStart = (performance.timing || {}).navigationStart || dateNow();
  return function () {
    return dateNow() - navigationStart;
  };
}());

present.performanceNow = performance.now;
present.noConflict = function () {
  performance.now = present.performanceNow;
};
present.conflict = function () {
  performance.now = present;
};
present.conflict();

module.exports = present;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],4:[function(require,module,exports){
const boardFuncs = require('./board');

exports.actions = (board, actionNum, activeOnly = true, presentOnly = true, newActiveTimelinesOnly = true, variant = 'standard', promotionPieces = null) => {
  var recurse =  (board, actionNum, layer = 0, totalMoves = 0, totalLayers = 0, totalIndex = []) => {
    var returnArr = [];
    var moves = boardFuncs.moves(board, actionNum, activeOnly, presentOnly, promotionPieces);
    for(var i = 0;i < moves.length;i++) {
      var moddedBoard = boardFuncs.copy(board);
      if(
        !newActiveTimelinesOnly ||
        (newActiveTimelinesOnly && (this.newTimelineIsActive(moddedBoard, actionNum) || (!this.newTimelineIsActive(moddedBoard, actionNum) && boardFuncs.positionIsLatest(moddedBoard, moves[i][1]))))
      ) {
        boardFuncs.move(moddedBoard, moves[i]);
        totalMoves++;
        if(boardFuncs.present(moddedBoard, actionNum).length > 0) {
          totalIndex[layer] = i;
          var recurseRes = recurse(moddedBoard, actionNum, layer + 1, totalMoves, totalLayers, totalIndex);
          var nextLayer = recurseRes[0];
          totalMoves = recurseRes[1];
          totalLayers = recurseRes[2] > layer ? recurseRes[2] : layer;
          totalIndex = recurseRes[3];
          for(var j = 0;j < nextLayer.length;j++) {
            var currArr = [moves[i]];
            for(var k = 0;k < nextLayer[j].length;k++) {
              currArr.push(nextLayer[j][k]);
            }
            returnArr.push(currArr);
          }
          if(nextLayer.length === 0) {
            returnArr.push([moves[i]]);
          }
        }
        else {
          returnArr.push([moves[i]]);
        }
      }
    }
    return [returnArr, totalMoves, totalLayers, totalIndex];
  }
  return recurse(board, actionNum)[0];
}

exports.move = (board, moves) => {
  for(var i = 0;i < moves.length;i++) {
    boardFuncs.move(board, moves[i]);
  }
}

exports.newTimelineIsActive = (board, actionNum) => {
  var minTimeline = 0;
  var maxTimeline = 0;
  for(var l = 0;board && l < board.length;l++) {
    if(board[l]) {
      if(minTimeline < l && l % 2 !== 0) {
        minTimeline = l;
      }
      if(maxTimeline < l && l % 2 === 0) {
        maxTimeline = l;
      }
    }
  }
  if(actionNum % 2 === 0) {
    return (minTimeline + 1) >= maxTimeline;
  }
  return (minTimeline + 1) <= maxTimeline;
}

exports.databaseHasBoard = (board, db) => {
  for(var i = 0;i < db.length;i++) {
    var comparison = boardFuncs.compare(board, db[i]);
    if(comparison === 0) {
      return true;
    }
  }
  db.push(boardFuncs.copy(board));
  return false;
}

},{"./board":5}],5:[function(require,module,exports){
const pieceFuncs = require('./piece');
const turnFuncs = require('./turn');
const parseFuncs = require('./parse');

exports.init = (variant) => {
  if(variant === 'defended_pawn') {
    return [[[
      [-8,-10,-4,-6,-12,-4,-6,-8],
      [-2,-2,-2,-2,-2,-2,-2,-2],
      [ 0, 0, 0, 0, 0, 0, 0, 0],
      [ 0, 0, 0, 0, 0, 0, 0, 0],
      [ 0, 0, 0, 0, 0, 0, 0, 0],
      [ 0, 0, 0, 0, 0, 0, 0, 0],
      [-1,-1,-1,-1,-1,-1,-1,-1],
      [-7,-9,-3,-5,-11,-3,-5,-7]
    ]]];
  }
  else if(variant === 'half_reflected') {
    return [[[
      [-8,-6,-4,-10,-12,-4,-6,-8],
      [-2,-2,-2,-2,-2,-2,-2,-2],
      [ 0, 0, 0, 0, 0, 0, 0, 0],
      [ 0, 0, 0, 0, 0, 0, 0, 0],
      [ 0, 0, 0, 0, 0, 0, 0, 0],
      [ 0, 0, 0, 0, 0, 0, 0, 0],
      [-1,-1,-1,-1,-1,-1,-1,-1],
      [-7,-5,-3,-11,-9,-3,-5,-7]
    ]]];
  }
  else if(variant === 'princess') {
    return [[[
      [-8,-6,-4,-14,-12,-4,-6,-8],
      [-2,-2,-2,-2,-2,-2,-2,-2],
      [ 0, 0, 0, 0, 0, 0, 0, 0],
      [ 0, 0, 0, 0, 0, 0, 0, 0],
      [ 0, 0, 0, 0, 0, 0, 0, 0],
      [ 0, 0, 0, 0, 0, 0, 0, 0],
      [-1,-1,-1,-1,-1,-1,-1,-1],
      [-7,-5,-3,-13,-11,-3,-5,-7]
    ]]];
  }
  else if(variant === 'reversed_royalty') {
    return [[[
      [-8,-6,-4,-20,-18,-4,-6,-8],
      [-2,-2,-2,-2,-2,-2,-2,-2],
      [ 0, 0, 0, 0, 0, 0, 0, 0],
      [ 0, 0, 0, 0, 0, 0, 0, 0],
      [ 0, 0, 0, 0, 0, 0, 0, 0],
      [ 0, 0, 0, 0, 0, 0, 0, 0],
      [-1,-1,-1,-1,-1,-1,-1,-1],
      [-7,-5,-3,-19,-17,-3,-5,-7]
    ]]];
  }
  else if(variant === 'turn_zero') {
    return [[
      null,
      [
        [-8,-6,-4,-10,-12,-4,-6,-8],
        [-2,-2,-2,-2,-2,-2,-2,-2],
        [ 0, 0, 0, 0, 0, 0, 0, 0],
        [ 0, 0, 0, 0, 0, 0, 0, 0],
        [ 0, 0, 0, 0, 0, 0, 0, 0],
        [ 0, 0, 0, 0, 0, 0, 0, 0],
        [-1,-1,-1,-1,-1,-1,-1,-1],
        [-7,-5,-3,-9,-11,-3,-5,-7]
      ],
      [
        [-8,-6,-4,-10,-12,-4,-6,-8],
        [-2,-2,-2,-2,-2,-2,-2,-2],
        [ 0, 0, 0, 0, 0, 0, 0, 0],
        [ 0, 0, 0, 0, 0, 0, 0, 0],
        [ 0, 0, 0, 0, 0, 0, 0, 0],
        [ 0, 0, 0, 0, 0, 0, 0, 0],
        [-1,-1,-1,-1,-1,-1,-1,-1],
        [-7,-5,-3,-9,-11,-3,-5,-7]
      ]
    ]];
  }
  else if(variant === 'two_timelines') {
    return [
      null,
      [[
        [-8,-6,-4,-10,-12,-4,-6,-8],
        [-2,-2,-2,-2,-2,-2,-2,-2],
        [ 0, 0, 0, 0, 0, 0, 0, 0],
        [ 0, 0, 0, 0, 0, 0, 0, 0],
        [ 0, 0, 0, 0, 0, 0, 0, 0],
        [ 0, 0, 0, 0, 0, 0, 0, 0],
        [-1,-1,-1,-1,-1,-1,-1,-1],
        [-7,-5,-3,-9,-11,-3,-5,-7]
      ]],
      [[
        [-8,-6,-4,-10,-12,-4,-6,-8],
        [-2,-2,-2,-2,-2,-2,-2,-2],
        [ 0, 0, 0, 0, 0, 0, 0, 0],
        [ 0, 0, 0, 0, 0, 0, 0, 0],
        [ 0, 0, 0, 0, 0, 0, 0, 0],
        [ 0, 0, 0, 0, 0, 0, 0, 0],
        [-1,-1,-1,-1,-1,-1,-1,-1],
        [-7,-5,-3,-9,-11,-3,-5,-7]
      ]]
    ];
  }
  else if (variant === 'custom') {
    return [];
  }
  else if(typeof variant === 'object') {
    return parseFuncs.toBoard(variant);
  }
  return [[[
    [-8,-6,-4,-10,-12,-4,-6,-8],
    [-2,-2,-2,-2,-2,-2,-2,-2],
    [ 0, 0, 0, 0, 0, 0, 0, 0],
    [ 0, 0, 0, 0, 0, 0, 0, 0],
    [ 0, 0, 0, 0, 0, 0, 0, 0],
    [ 0, 0, 0, 0, 0, 0, 0, 0],
    [-1,-1,-1,-1,-1,-1,-1,-1],
    [-7,-5,-3,-9,-11,-3,-5,-7]
  ]]];
}

exports.copy = (board) => {
  var res = [];
  for(var l = 0;board && l < board.length;l++) {
    if(board[l]) {
      res[l] = [];
    }
    for(var t = 0;board[l] && t < board[l].length;t++) {
      if(board[l][t]) {
        res[l][t] = [];
      }
      var newTurn = turnFuncs.copy(board, l, t);
      this.setTurn(res, l, t, newTurn);
    }
  }
  return res;
}

exports.setTurn = (board, timeline, time, turn) => {
  //Function to set small board/turn for full board. Used to avoid PACKED -> HOLEY element transistion on v8 engine.
  if(!Array.isArray(board)) {
    board = [];
  }
  for(var l = 0;l <= timeline;l++) {
    if(l === timeline) {
      if(!Array.isArray(board[l])) {
        board[l] = [];
      }
      for(var t = 0;t <= time;t++) {
        if(t === time) {
          board[l][t] = turn;
        }
        else if(t >= board[l].length || typeof board[l][t] === 'undefined') {
          board[l][t] = null;
        }
      }
    }
    else if(l >= board.length || typeof board[l] === 'undefined') {
      board[l] = null;
    }
  }
}

exports.move = (board, move) => {
  if(this.positionExists(board, move[0]) && this.positionIsLatest(board, move[0])) {
    var src = move[0];
    var dest = move[1];
    var newTurn = turnFuncs.copy(board, src[0], src[1]);
    var destPiece = dest[4] ? dest[4] : Math.abs(newTurn[src[2]][src[3]]);
    if(destPiece !== undefined && destPiece !== 0) {
      newTurn[src[2]][src[3]] = 0;
      if(dest !== undefined) {
        if(dest[0] === src[0] && dest[1] === src[1]) {
          newTurn[dest[2]][dest[3]] = destPiece;
        }
        else {
          var secondNewTurn = turnFuncs.copy(board, dest[0], dest[1]);
          secondNewTurn[dest[2]][dest[3]] = destPiece;
          if((board[dest[0]].length - 1) === dest[1]) {
            this.setTurn(board, dest[0], dest[1] + 1, secondNewTurn);
          }
          else {
            var newTimeline = 0;
            for(var i = 1;i < board.length;i++) {
              if(!(typeof board[i] === 'undefined' || board[i] === null) && (i % 2) === (dest[1] % 2)) {
                if(newTimeline < i) { newTimeline = i; }
              }
            }
            if(newTimeline === 0) {
              board[(dest[1] % 2) === 0 ? 2 : 1] = [];
              this.setTurn(board, (dest[1] % 2) === 0 ? 2 : 1, dest[1] + 1, secondNewTurn);
            }
            else {
              board[newTimeline + 2] = [];
              this.setTurn(board, newTimeline + 2, dest[1] + 1, secondNewTurn);
            }
          }
        }
      }
      this.setTurn(board, src[0], src[1] + 1, newTurn);
    }
    if(move[2] !== undefined) {
      var src2 = move[2];
      if(move[3] !== undefined) {
        var dest2 = move[3];
        var destPiece2 = dest2[4] ? dest2[4] : Math.abs(board[src2[0]][src2[1]][src2[2]][src2[3]]);
        if(dest2 !== undefined) {
          board[dest2[0]][dest2[1] + 1][dest2[2]][dest2[3]] = destPiece2;
        }
      }
      board[src2[0]][src2[1] + 1][src2[2]][src2[3]] = 0;
    }
  }
}

exports.positionExists = (board, pos) => {
  return Boolean(
    board !== undefined &&
    board !== null &&
    board[pos[0]] &&
    board[pos[0]][pos[1]] &&
    board[pos[0]][pos[1]][pos[2]] &&
    Number.isInteger(board[pos[0]][pos[1]][pos[2]][pos[3]])
  );
}

exports.positionIsLatest = (board, pos) => {
  if(this.positionExists(board, pos)) {
    return (board[pos[0]].length - 1) === pos[1];
  }
  return false;
}

exports.active = (board) => {
  var res = [];
  var minTimeline = 0;
  var maxTimeline = 0;
  for(var l = 0;board && l < board.length;l++) {
    if(board[l]) {
      if(minTimeline < l && l % 2 !== 0) {
        minTimeline = l;
      }
      if(maxTimeline < l && l % 2 === 0) {
        maxTimeline = l;
      }
    }
  }
  for(var l = 0;board && l < board.length;l++) {
    if(board[l]) {
      if(maxTimeline + 1 >= l && l % 2 !== 0) {
        res.push(l);
      }
      if(minTimeline + 3 >= l && l % 2 === 0) {
        res.push(l);
      }
    }
  }
  return res;
}

exports.present = (board, actionNum) => {
  var res = [];
  var activeTimelines = this.active(board);
  var lowestTurn = -1;
  for(var i = 0;i < activeTimelines.length;i++) {
    var currMax = -1;
    for(var t = 0;t < board[activeTimelines[i]].length;t++) {
      if(board[activeTimelines[i]][t] !== undefined && currMax < t && actionNum % 2 === t % 2) {
        currMax = t;
      }
    }
    if(currMax !== -1) {
      if(lowestTurn === -1 || lowestTurn > currMax) {
        lowestTurn = currMax;
      }
    }
  }
  if(lowestTurn >= 0) {
    for(var i = 0;i < activeTimelines.length;i++) {
      var currMax = 0;
      for(var t = 0;t < board[activeTimelines[i]].length;t++) {
        if(board[activeTimelines[i]][t] && currMax < t) {
          currMax = t;
        }
      }
      if(lowestTurn === currMax) {
        res.push(activeTimelines[i]);
      }
      else if(lowestTurn > currMax) {
        return [];
      }
    }
  }
  return res;
}

exports.moves = (board, actionNum, activeOnly = true, presentOnly = true, spatialOnly = false, promotionPieces = null) => {
  var res = [];
  if(presentOnly) {
    var presentTimelines = this.present(board, actionNum);
    for(var i = 0;i < presentTimelines.length;i++) {
      if(board[presentTimelines[i]]) {
        var currTimeline = board[presentTimelines[i]];
        var latestTurn = currTimeline[currTimeline.length - 1];
        if((currTimeline.length - 1) % 2 === actionNum % 2) {
          for(var r = 0;latestTurn && r < latestTurn.length;r++) {
            for(var f = 0;latestTurn[r] && f < latestTurn[r].length;f++) {
              var piece = Math.abs(latestTurn[r][f]);
              if(piece !== 0 && piece % 2 === actionNum % 2) {
                var moves = pieceFuncs.moves(board, [presentTimelines[i], currTimeline.length - 1, r, f], spatialOnly, promotionPieces);
                for(var j = 0;j < moves.length;j++) {
                  res.push(moves[j]);
                }
              }
            }
          }
        }
      }
    }
  }
  else if(activeOnly) {
    var activeTimelines = this.active(board);
    for(var i = 0;i < activeTimelines.length;i++) {
      if(board[activeTimelines[i]]) {
        var currTimeline = board[activeTimelines[i]];
        var latestTurn = currTimeline[currTimeline.length - 1];
        if((currTimeline.length - 1) % 2 === actionNum % 2) {
          for(var r = 0;latestTurn && r < latestTurn.length;r++) {
            for(var f = 0;latestTurn[r] && f < latestTurn[r].length;f++) {
              var piece = Math.abs(latestTurn[r][f]);
              if(piece !== 0 && piece % 2 === actionNum % 2) {
                var moves = pieceFuncs.moves(board, [activeTimelines[i], currTimeline.length - 1, r, f], spatialOnly, promotionPieces);
                for(var j = 0;j < moves.length;j++) {
                  res.push(moves[j]);
                }
              }
            }
          }
        }
      }
    }
  }
  else {
    for(var l = 0;board && l < board.length;l++) {
      var currTimeline = board[l];
      if(currTimeline) {
        var latestTurn = currTimeline[currTimeline.length - 1];
        if((currTimeline.length - 1) % 2 === actionNum % 2) {
          for(var r = 0;latestTurn && r < latestTurn.length;r++) {
            for(var f = 0;latestTurn[r] && f < latestTurn[r].length;f++) {
              var piece = Math.abs(latestTurn[r][f]);
              if(piece !== 0 && piece % 2 === actionNum % 2) {
                var moves = pieceFuncs.moves(board, [l, currTimeline.length - 1, r, f], spatialOnly, promotionPieces);
                for(var j = 0;j < moves.length;j++) {
                  res.push(moves[j]);
                }
              }
            }
          }
        }
      }
    }
  }
  return res;
}

//Only single board, not full board (does not check across time / timelines)
//Used for castling
exports.positionIsAttacked = (board, pos, player) => {
  var toCheck = [];
  if(this.positionExists(board, pos)) {
    var movePos = pieceFuncs.movePos(6); //Knight movement
    var moveVecs = pieceFuncs.moveVecs(10); //Queen movement
    for(var i = 0;i < movePos.length;i++) {
      var newSrc = pos.slice();
      if(
        movePos[i][0] === 0 &&
        movePos[i][1] === 0 &&
        (movePos[i][2] !== 0 || movePos[i][3] !== 0)
      ) {
        newSrc[2] += movePos[i][2];
        newSrc[3] += movePos[i][3];
        if(this.positionExists(board, newSrc)) {
          var destPiece = board[newSrc[0]][newSrc[1]][newSrc[2]][newSrc[3]];
          if(destPiece !== 0 && Math.abs(destPiece) % 2 !== player) {
            toCheck.push(newSrc.slice());
          }
        }
      }
    }
    for(var i = 0;i < moveVecs.length;i++) {
      if(
        moveVecs[i][0] === 0 &&
        moveVecs[i][1] === 0 &&
        (moveVecs[i][2] !== 0 || moveVecs[i][3] !== 0)
      ) {
        var newSrc = pos.slice();
        var blocking = false;
        while(!blocking) {
          newSrc[2] += moveVecs[i][2];
          newSrc[3] += moveVecs[i][3];
          if(this.positionExists(board, newSrc)) {
            var destPiece = board[newSrc[0]][newSrc[1]][newSrc[2]][newSrc[3]];
            if(destPiece !== 0) {
              blocking = true;
              if(Math.abs(destPiece) % 2 !== player) {
                toCheck.push(newSrc.slice());
              }
            }
          }
          else {
            blocking = true;
          }
        }
      }
    }
    //Generate moves from toCheck Arr
    for(var i = 0;i < toCheck.length;i++) {
      var moves = pieceFuncs.moves(board, toCheck[i], true);
      for(var j = 0;j < moves.length;j++) {
        if(this.positionIsLatest(board, moves[j][0])) {
          if (
            moves[j].length === 2 &&
            moves[j][1][0] === pos[0] &&
            moves[j][1][1] === pos[1] &&
            moves[j][1][2] === pos[2] &&
            moves[j][1][3] === pos[3]
          ) {
            return true;
          }
          if (
            moves[j].length === 3 &&
            moves[j][2][0] === pos[0] &&
            moves[j][2][1] === pos[1] &&
            moves[j][2][2] === pos[2] &&
            moves[j][2][3] === pos[3]
          ) {
            return true;
          }
        }
      }
    }
  }
  return false;
}

exports.isTurnZero = (board) => {
  //Checking if turn exists at the zero index
  var hasZeroIndex = false;
  if(Array.isArray(board) && board.length > 0) {
    for(var l = 0;l < board.length;l++) {
      if(Array.isArray(board[l]) && board[l].length > 0) {
        if(Array.isArray(board[l][0])) {
          hasZeroIndex = true;
        }
      }
    }
    //Inverted, since turn zero is the lack of a zero index turn (i.e. first turn starts from the index of 1)
    return !hasZeroIndex;
  }
  //Default to false
  return false;
}

exports.isEvenTimeline = (board) => {
  //Checking if the zero index timeline exists
  if(Array.isArray(board) && board.length > 0) {
    if(Array.isArray(board[0])) {
      //Not even timelines if a timeline exists at the zero index
      return false;
    }
    return true;
  }
  //Default to false
  return false;
}

exports.isNormalCastling = (board) => {
  //Check if initial boards (not full board) can use O-O notation format
  var hasNonNormalCastling = false;
  var isTurnZero = this.isTurnZero(board);
  if(Array.isArray(board) && board.length > 0) {
    for(var l = 0;l < board.length;l++) {
      if(Array.isArray(board[l]) && board[l].length > 0) {
        var currTurn = board[l][0];
        if(isTurnZero) {
          currTurn = board[l][2];
        }
        if(Array.isArray(currTurn)) {
          if(currTurn[0][4] !== -12 || currTurn[7][4] !== -11) {
            hasNonNormalCastling = true;
          }
        }
      }
    }
    //Inverted, since normal castling means no initial board contains non-normal castling
    return !hasNonNormalCastling;
  }
  //Default to false
  return false;
}

exports.compare = (board1, board2) => {
  //Note: accidentally used t instead of l for timeline and l instead of t for turn
  if(Array.isArray(board1)) {
    if(Array.isArray(board2) && board1.length === board2.length) {
      for(var t = 0;t < board1.length;t++) {
        if(Array.isArray(board1[t])) {
          if(Array.isArray(board2[t]) && board1[t].length === board2[t].length) {
            for(var l = 0;l < board1[t].length;l++) {
              if(Array.isArray(board1[t][l])) {
                if(Array.isArray(board2[t][l]) && board1[t][l].length === board2[t][l].length) {
                  for(var r = 0;r < board1[t][l].length;r++) {
                    if(Array.isArray(board1[t][l][r])) {
                      if(Array.isArray(board2[t][l][r]) && board1[t][l][r].length === board2[t][l][r].length) {
                        for(var f = 0;f < board1[t][l][r].length;f++) {
                          if(board1[t][l][r][f] !== undefined) {
                            if(board2[t][l][r][f] !== undefined) {
                              if(board1[t][l][r][f] !== board2[t][l][r][f]) {
                                return board1[t][l][r][f] - board2[t][l][r][f];
                              }
                            }
                            else {
                              return -1;
                            }
                          }
                          else {
                            if(board2[t][l][r][f] !== undefined) {
                              return 1;
                            }
                          }
                        }
                      }
                      else {
                        return -1;
                      }
                    }
                    else {
                      if(Array.isArray(board2[t][l][r])) {
                        return 1;
                      }
                    }
                  }
                }
                else {
                  return -1;
                }
              }
              else {
                if(Array.isArray(board2[t][l])) {
                  return 1;
                }
              }
            }
          }
          else {
            return -1;
          }
        }
        else {
          if(Array.isArray(board2[t])) {
            return 1;
          }
        }
      }
    }
    else {
      return -1;
    }
  }
  else {
    if(Array.isArray(board2)) {
      return 1;
    }
    else {
      return 0;
    }
  }
  return 0;
}

},{"./parse":14,"./piece":16,"./turn":18}],6:[function(require,module,exports){
require('module-alias/register');

const boardFuncs = require('./board');
const notationFuncs = require('./notation');
const pgnFuncs = require('./pgn');
const parseFuncs = require('./parse');
const validateFuncs = require('./validate');

exports.board = (input) => {
  /*
    Supported input:
     - 4D Array (raw board)
     - Board object
     - JSON of either above
  */
  var res = [];
  var tmp = input;
  if(typeof input === 'string') {
    tmp = null;
    try {
      tmp = JSON.parse(input);
    }
    catch(err) {}
  }
  if(Array.isArray(tmp)) {
    res = boardFuncs.copy(tmp);
  }
  else {
    res = parseFuncs.toBoard(tmp);
  }
  return res;
}

exports.actions = (input, startingBoard = [], startingActionNum = [], promotionPieces = null) => {
  /*
    Supported input:
     - 2D Array of moves (raw or object)
     - Array of action object
     - JSON of either above
     - Multiple actions as expressed in notation / pgn
  */
  var res = [];
  if(typeof input === 'string') {
    input = input.split('\n').map(e => e.trim()).filter(e => !e.startsWith('[') && e).join('\n').trim();
    var tmp = null;
    try {
      tmp = JSON.parse(input);
    }
    catch(err) {}
    if(tmp === null) {
      try {
        tmp = pgnFuncs.toActionHistory(input, startingBoard, startingActionNum, promotionPieces);
        if(tmp.length <= 0 && input.length > 0) {
          tmp = null;
          throw 'No pgn actions found';
        }
      }
      catch(err) {
        console.warn('Error parsing as pgn, trying old notation: ' + err);
        if (err instanceof Error) {
          console.error(err);
        }
      }
    }
    if(tmp === null) {
      var splitStr = input.replace(/\r\n/g, '\n').replace(/\s*;\s*/g, '\n').split('\n').map(e => e.trim()).filter(e => !e.includes('[') && e !== '');
      var tmpAction = [];
      var tmpCurrAction = null;
      for(var i = 0;i < splitStr.length;i++) {
        if(splitStr[i].length > 0) {
          var tmpNotation = {};
          try {
            if(validateFuncs.notation(splitStr[i])) {
              tmpNotation = notationFuncs.moveNotation(null, 0, splitStr[i]);
            }
            else {
              console.error('Line is not considered notation: ' + splitStr[i]);
            }
          }
          catch(err) {
            console.error(err);
            throw 'Notation invalid and an error has occurred at line: ' + splitStr[i];
          }
          if(tmpCurrAction === null) {
            tmpCurrAction = tmpNotation.action;
          }
          if(tmpNotation.action > tmpCurrAction) {
            if(tmpAction.length > 0) {
              res.push(tmpAction);
              tmpAction = [];
            }
            tmpCurrAction = tmpNotation.action;
          }
          tmpAction.push(tmpNotation.arr);
        }
      }
      if(tmpAction.length > 0) {
        res.push(tmpAction);
      }
    }
    else {
      input = tmp;
    }
  }
  if(Array.isArray(input)) {
    var tmpBoard = boardFuncs.copy(startingBoard);
    var tmpActionNum = startingActionNum;
    for(var i = 0;i < input.length;i++) {
      res.push(this.action(input[i], tmpBoard, tmpActionNum));
      for(var j = 0;j < input[i].length;j++) {
        boardFuncs.move(tmpBoard, input[i][j]);
      }
      tmpActionNum++;
    }
  }
  return res;
}

exports.action = (input, board = [], actionNum = 0, promotionPieces = null) => {
  /*
    Supported input:
     - Array of moves (raw or object)
     - Action object
     - JSON of either above
     - Single action as expressed in notation
  */
  var res = [];
  var isTurnZero = boardFuncs.isTurnZero(board);
  if(typeof input === 'string') {
    var tmp = null;
    try {
      tmp = JSON.parse(input);
    }
    catch(err) {}
    if(tmp === null) {
      try {
        tmp = pgnFuncs.toAction(input, board, actionNum, promotionPieces);
      }
      catch(err) {
        console.warn('Error parsing as pgn, trying old notation: ' + err);
        if (err instanceof Error) {
          console.error(err);
        }
      }
    }
    if(tmp === null) {
      var splitStr = input.replace(/\r\n/g, '\n').replace(/\s*;\s*/g, '\n').split('\n').filter(e => !e.includes('[') && e !== '');
      var tmpAction = [];
      for(var i = 0;i < splitStr.length;i++) {
        if(splitStr[i].length > 0) {
          var tmpNotation = {};
          try {
            if(validateFuncs.notation(splitStr[i])) {
              tmpNotation = notationFuncs.moveNotation(null, 0, splitStr[i]);
            }
            else {
              console.error('Line is not considered notation: ' + splitStr[i]);
            }
          }
          catch(err) {
            console.error(err);
            throw 'Notation invalid and an error has occurred at line: ' + splitStr[i];
          }
          tmpAction.push(tmpNotation.arr);
        }
      }
      if(tmpAction.length > 0) {
        res = tmpAction;
      }
    }
    else {
      input = tmp;
    }
  }
  if(!Array.isArray(input) && typeof input === 'object') {
    input = input.moves;
  }
  if(Array.isArray(input)) {
    if(input.length > 0 && !Array.isArray(input[0])) {
      for(var i = 0;i < input.length;i++) {
        res.push(parseFuncs.toMove(input[i], isTurnZero));
      }
    }
    else {
      res = input;
    }
  }
  return res;
}

exports.move = (input, board = [], actionNum = 0, promotionPieces = null) => {
  /*
    Supported input:
     - Move (raw or object)
     - JSON of either above
     - Single move as expressed in notation
  */
  var res = [];
  var isTurnZero = boardFuncs.isTurnZero(board);
  if(typeof input === 'string') {
    var tmp = null;
    try {
      tmp = JSON.parse(input);
    }
    catch(err) {}
    if(tmp === null) {
      try {
        tmp = pgnFuncs.toMove(input, board, actionNum, [], promotionPieces);
      }
      catch(err) {
        console.warn('Error parsing as pgn, trying old notation: ' + err);
        if (err instanceof Error) {
          console.error(err);
        }
      }
    }
    if(tmp === null) {
      var splitStr = input.replace(/\r\n/g, '\n').replace(/\s*;\s*/g, '\n').split('\n').filter(e => !e.includes('[') && e !== '');
      if(splitStr.length > 0) {
        if(validateFuncs.notation(splitStr[0])) {
          res = notationFuncs.moveNotation(null, 0, splitStr[0]).arr;
        }
      }
    }
    else {
      input = tmp;
    }
  }
  if(Array.isArray(input)) {
    res = input;
  }
  else if(typeof input === 'object') {
    res = parseFuncs.toMove(input, isTurnZero);
  }
  return res;
}

},{"./board":5,"./notation":13,"./parse":14,"./pgn":15,"./validate":19,"module-alias/register":2}],7:[function(require,module,exports){
exports.move = (move) => {
  var res = [];
  for(var i = 0;i < move.length;i++) {
    res.push(move[i].slice());
  }
  return res;
}

exports.action = (action) => {
  var res = [];
  for(var i = 0;i < action.length;i++) {
    res.push(this.move(action[i]));
  }
  return res;
}

exports.actions = (actions) => {
  var res = [];
  for(var i = 0;i < actions.length;i++) {
    res.push(this.action(actions[i]));
  }
  return res;
}
},{}],8:[function(require,module,exports){
/*! # FEN Conversion utilities

    This module contains a few functions allowing the conversion from/to 5DFEN.

    The FEN format is described in [fen.ebnf](https://github.com/adri326/5dchess-notation/blob/master/fen.ebnf).
*/

exports.TO_FEN = ['', 'p', 'P', 'b', 'B', 'n', 'N', 'r', 'R', 'q', 'Q', 'k', 'K', 's', 'S', 'w', 'W', 'c', 'C', 'y', 'Y', 'u', 'U', 'd', 'D'];
exports.FROM_FEN = {
    'p': 1,
    'P': 2,
    'b': 3,
    'B': 4,
    'n': 5,
    'N': 6,
    'r': 7,
    'R': 8,
    'q': 9,
    'Q': 10,
    'k': 11,
    'K': 12,
    's': 13,
    'S': 14,
    'w': 15,
    'W': 16,
    'c': 17,
    'C': 18,
    'y': 19,
    'Y': 20,
    'u': 21,
    'U': 22,
    'd': 23,
    'D': 24,
};
exports.OMMIT_UNMOVED = [
    true,           //none
    false, false,   //pawn
    true, true,     //bishop
    true, true,     //knight
    false, false,   //rook
    true, true,     //queen
    false, false,   //king
    true, true,     //princess
    false, false,   //brawn
    true, true,     //common king
    true, true,     //royal queen
    true, true,     //unicorn
    true, true,     //dragon
];

/**
    Converts a raw turn (`turn`) into a 5DFEN board string.
**/
exports.toFen = (turnObj, l, t, isTurnZero = false, isEvenTimeline = false) => {
    let blanks = 0;
    let res = '';
    for (var row = turnObj.length - 1;row >= 0;row--) {
        for (let piece of turnObj[row]) {
            if (piece == 0) {
                blanks++;
            } else if (blanks > 0) {
                res += blanks.toString(10);
                blanks = 0;
            }

            if (piece != 0) {
                let unmoved = piece < 0;
                piece = Math.abs(piece);
                if (exports.TO_FEN[piece]) {
                    res += exports.TO_FEN[piece];
                } else {
                    res += '?';
                }
                if (unmoved && !exports.OMMIT_UNMOVED[piece]) {
                    res += '*';
                }
            }
        }
        if (blanks > 0) {
            res += blanks.toString(10);
            blanks = 0;
        }
        res += '/';
    }
    res = res.slice(0, -1); // remove the last `/`

    res += ':';

    if (l % 2 === 1) {
        l = -(l + 1) / 2;
    } else {
        l /= 2;
    }
    if(isEvenTimeline) {
        if (l > 0) {
            res += '+' + Math.floor(l - 1);
        } else if (l < 0) {
            res += '-' + Math.floor(-(l + 1));
        } else {
            res += '0';
        }
    }
    else {
        if (l > 0) {
            res += '+' + Math.floor(l);
        } else if (l < 0) {
            res += '-' + Math.floor(-l);
        } else {
            res += '0';
        }
    }

    res += ':';
    if(isTurnZero) {
        res += Math.floor(t / 2);
    }
    else {
        res += Math.floor(t / 2) + 1;
    }
    res += ':';
    res += t % 2 ? 'b' : 'w';

    return `[${res}]`;
}

/**
    Converts a 5DFEN board string into its corresponding internal board and position.
**/
exports.fromFen = (raw, width = 8, height = 8, isTurnZero = false, isEvenTimeline = false) => {
    if (typeof raw !== 'string') {
        throw new Error("TypeError: expected argument `raw` to be of type `string`, got: " + typeof raw);
    }
    if (raw.startsWith('[') && raw.endsWith(']')) {
        raw = raw.slice(1, -1);
    }
    let split = raw.split(':');
    if (split.length !== 4) {
        throw new Error("SyntaxError: raw 5DFEN board string doesn't have 4 fields.");
    }
    let rows = split[0].split('/');
    if (rows.length !== height) {
        throw new Error("SyntaxError: the amount of rows isn't equal to the height of the board, did you forget a slash (/) or to set the `size` header?");
    }
    let board = [];
    for (let raw_row of rows) {
        let row = [];
        while (raw_row.length) {
            let match;
            if (match = /^\d+/.exec(raw_row)) {
                raw_row = raw_row.slice(match[0].length);
                for (let n = 0; n < +match[0]; n++) {
                    row.push(0);
                }
            } else if (match = /^\+?([a-zA-Z])(\*?)/.exec(raw_row)) {
                raw_row = raw_row.slice(match[0].length);
                let piece = exports.FROM_FEN[match[1]];
                if (!piece) {
                    throw new Error(`SyntaxError: invalid piece '${match[1]}'`);
                }
                row.push(match[2] ? -piece : piece);
            } else {
                throw new Error(`SyntaxError: unexpected character: '${raw_row[0]}'`)
            }
        }
        if (row.length !== width) {
            throw new Error("SyntaxError: row doesn't have the right width, did you forget a slash (/) or to set the `size` header?");
        }
        board.push(row);
    }
    var reversedTurn = [];
    for(var i = board.length - 1;i >= 0;i--) {
        reversedTurn.push(board[i]);
    }

    let l;
    if (split[1] === '-0' || split[1] === '+0') {
        l = 0;
    } else {
        l = +split[1];
    }
    if(isEvenTimeline) {
        if (split[1] === '-0') {
            l = -1;
        }
        else if (split[1] === '+0') {
            l = 1;
        } else {
            l = +split[1];
            if(l < 0) {
                l--;
            }
            else {
                l++;
            }
        }
    }

    if (isNaN(l)) {
        throw new Error("Invalid FEN timeline: " + split[1]);
    } else if (l < 0) {
        l = -l * 2 - 1;
    } else {
        l *= 2;
    }

    let t = +split[2] * 2;

    if (isNaN(t)) {
        throw new Error("Invalid FEN turn: " + split[2]);
    }
    if(isTurnZero) {
        t += 2;
    }

    if (split[3] === 'w') {
        t -= 2;
    } else if (split[3] === 'b') {
        t -= 1;
    } else {
        throw new Error("Invalid FEN color: " + split[3]);
    }

    return [reversedTurn, l, t];
}

},{}],9:[function(require,module,exports){
const md5 = require('blueimp-md5');

exports.hash = (board) => {
  var res = '';
  for(var l = 0;board && l < board.length;l++) {
    if(board[l]) {
      for(var t = 0;t < board[l].length;t++) {
        if(board[l][t]) {
          var zeroSum = 0;
          for(var r = 0;r < board[l][t].length;r++) {
            for(var f = 0;f < board[l][t][r].length;f++) {
              var piece = board[l][t][r][f];
              if(piece === 0) {
                zeroSum++;
              }
              else {
                if(zeroSum > 0) {
                  res += '' + zeroSum;
                  zeroSum = 0;
                }
                if(piece > 0) {
                  res += String.fromCharCode(97 + piece);
                }
                else {
                  res += String.fromCharCode(67 + Math.abs(piece));
                }
              }
            }
          }
        }
        else {
          res += 'B';
        }
      }
    }
    else {
      res += 'A';
    }
  }
  return md5(res);
}

exports.hashBoard = (board, timeline, turn) => {
  var res = '';
  var l = timeline;
  var t = turn;
  if(board[l][t]) {
    var zeroSum = 0;
    for(var r = 0;r < board[l][t].length;r++) {
      for(var f = 0;f < board[l][t][r].length;f++) {
        var piece = board[l][t][r][f];
        if(piece === 0) {
          zeroSum++;
        }
        else {
          if(zeroSum > 0) {
            res += '' + zeroSum;
            zeroSum = 0;
          }
          if(piece > 0) {
            res += String.fromCharCode(97 + piece);
          }
          else {
            res += String.fromCharCode(67 + Math.abs(piece));
          }
        }
      }
    }
  }
  else {
    res += 'B';
  }
  return md5(res);
}
},{"blueimp-md5":1}],10:[function(require,module,exports){
require('module-alias/register');
const md5 = require('blueimp-md5');

const actionFuncs = require('./action');
const boardFuncs = require('./board');
const convertFuncs = require('./convert');
const copyFuncs = require('./copy');
const fenFuncs = require('./fen');
const hashFuncs = require('./hash');
const parseFuncs = require('./parse');
const pgnFuncs = require('./pgn');
const pieceFuncs = require('./piece');
const printFuncs = require('./print');
const mateFuncs = require('./mate');
const metadataFuncs = require('./metadata');
const notationFuncs = require('./notation');
const turnFuncs = require('./turn');
const validateFuncs = require('./validate');

class Chess {
  constructor(input, variant) {
    this.raw = {
      actionFuncs: actionFuncs,
      boardFuncs: boardFuncs,
      convertFuncs: convertFuncs,
      fenFuncs: fenFuncs,
      hashFuncs: hashFuncs,
      mateFuncs: mateFuncs,
      metadataFuncs: metadataFuncs,
      notationFuncs: notationFuncs,
      parseFuncs: parseFuncs,
      pgnFuncs: pgnFuncs,
      pieceFuncs: pieceFuncs,
      printFuncs: printFuncs,
      turnFuncs: turnFuncs,
      validateFuncs: validateFuncs
    };
    this.checkmateTimeout = 60000;
    this.skipDetection = false;
    this.checkmateCache = [];
    this.metadata = {
      board: 'standard',
      mode: '5D'
    };
    this.rawPromotionPieces = []; //TODO: Expose this variable as endpoint for getting available promotions options
    if(typeof input !== 'undefined') {
      this.import(input, variant);
    }
    else {
      if(typeof variant === 'string') {
        this.metadata.board = metadataFuncs.lookupVariant(variant);
        this.reset(this.metadata.board);
      }
      else if(typeof variant === 'object') {
        this.metadata.board = 'custom';
        this.reset(variant);
      }
      else {
        this.reset();
      }
    }
  }
  copy() {
    var newInstance = new Chess();
    newInstance.state(this.state());
    return newInstance;
  }
  state(state = null) {
    if(state === null) {
      var res = {};
      res.checkmateTimeout = this.checkmateTimeout;
      res.skipDetection = this.skipDetection;
      res.checkmateCache = this.checkmateCache.slice();
      res.metadata = Object.assign({}, this.metadata);
      res.rawAction = this.rawAction;
      res.rawStartingAction = this.rawStartingAction;
      res.rawBoardHistory = [];
      for(var i = 0;i < this.rawBoardHistory.length;i++) {
        res.rawBoardHistory.push(boardFuncs.copy(this.rawBoardHistory[i]));
      }
      res.rawBoard = boardFuncs.copy(this.rawBoard);
      res.rawActionHistory = copyFuncs.actions(this.rawActionHistory);
      res.rawMoveBuffer = copyFuncs.action(this.rawMoveBuffer);
      res.rawPromotionPieces = this.rawPromotionPieces.slice();
      return res;
    }
    else {
      this.checkmateTimeout = state.checkmateTimeout;
      this.skipDetection = state.skipDetection;
      this.checkmateCache = state.checkmateCache.slice();
      this.metadata = Object.assign({}, state.metadata);
      this.rawAction = state.rawAction;
      this.rawStartingAction = state.rawStartingAction;
      this.rawBoardHistory = [];
      for(var i = 0;i < state.rawBoardHistory.length;i++) {
        this.rawBoardHistory.push(boardFuncs.copy(state.rawBoardHistory[i]));
      }
      this.rawBoard = boardFuncs.copy(state.rawBoard);
      this.rawActionHistory = copyFuncs.actions(state.rawActionHistory);
      this.rawMoveBuffer = copyFuncs.action(state.rawMoveBuffer);
      this.rawPromotionPieces = state.rawPromotionPieces.slice();
    }
  }
  compare(input1, input2, type = 'board') {
    if(type === 'board') {
      var board1 = convertFuncs.board(input1);
      var board2 = convertFuncs.board(input2);
      return boardFuncs.compare(board1, board2);
    }
    if(type === 'move') {
      var move1 = convertFuncs.move(input1, this.rawBoard, this.rawAction, this.rawPromotionPieces);
      var move2 = convertFuncs.move(input2, this.rawBoard, this.rawAction, this.rawPromotionPieces);
      return mateFuncs.moveCompare(move1, move2);
    }
    throw 'Type not supported, valid types are \'board\' and \'move\'.';
  }
  reset(variant) {
    if(typeof variant === 'string') {
      this.metadata.board = metadataFuncs.lookupVariant(variant);
      this.rawBoard = boardFuncs.init(this.metadata.board);
    }
    else if(typeof variant === 'object') {
      this.metadata.board = 'custom';
      this.rawBoard = boardFuncs.init(variant);
    }
    else {
      this.rawBoard = boardFuncs.init(this.metadata.board);
    }
    this.rawAction = 0;
    if(typeof this.rawBoard[0] !== 'undefined' && this.rawBoard[0] !== null) {
      this.rawAction = this.rawBoard[0].length % 2 === 0 ? 1 : 0;
    }
    this.rawStartingAction = this.rawAction;
    this.rawBoardHistory = [boardFuncs.copy(this.rawBoard)];
    this.rawActionHistory = [];
    this.rawMoveBuffer = [];
    this.rawPromotionPieces = pieceFuncs.availablePromotionPieces(this.rawBoard);
  }
  import(input, variant) {
    //Reset everything to "Standard" first
    this.reset('standard');
    if(typeof input === 'string') {
      Object.assign(this.metadata, metadataFuncs.strToObj(input));
      if (typeof this.metadata.board === 'string') {
        this.reset(this.metadata.board);
      } else {
        this.reset(variant);
      }
    } else {
      this.reset(variant);
    }

    if (this.metadata.promotions) {
      this.rawPromotionPieces = [];
      for (let promotions of this.metadata.promotions.split(',')) {
        this.rawPromotionPieces.push(pieceFuncs.fromChar(promotions, 0));
        this.rawPromotionPieces.push(pieceFuncs.fromChar(promotions, 1));
      }
    }
    if(this.metadata.board === 'custom') {
      this.fen(input);
      if(typeof this.rawBoard[0] !== 'undefined' && this.rawBoard[0] !== null) {
        this.rawAction = this.rawBoard[0].length % 2 === 0 ? 1 : 0;
      }
      this.rawStartingAction = this.rawAction;
      this.rawBoardHistory = [boardFuncs.copy(this.rawBoard)];
    }
    try {
      var actions = convertFuncs.actions(input, this.rawBoardHistory[0], this.rawStartingAction, this.rawPromotionPieces);
      for(var i = 0;i < actions.length;i++) {
        for(var j = 0;j < actions[i].length;j++) {
          this.move(actions[i][j]);
        }
        if(i + 1 < actions.length) {
          this.submit();
        }
        else {
          try {
            this.submit();
          }
          catch(err) {
            console.error(err);
            console.log('Last action is not complete, importing as move buffer.');
          }
        }
      }
    }
    catch(err) {
      console.error(err);
      console.log('Error importing actions, skipping.');
    }
  }
  importable(input) {
    try {
      var newInstance = this.copy();
      newInstance.import(input);
      return true;
    }
    catch(err) { return false; }
  }
  fen(input, currentBoard = false) {
    if(typeof input === 'string') {
      // Read width and height
      let width = 8;
      let height = 8;

      let match;
      Object.assign(this.metadata, metadataFuncs.strToObj(input));
      if(match = /^(\d+)x(\d+)$/.exec(this.metadata.size || "")) {
        width = +match[1];
        height = +match[2];
      }
      var isTurnZero = input.includes('0:b]') || input.includes('0:w]');
      var isEvenTimeline = input.includes(':+0:') || input.includes(':-0:');
      // Look for 5DFEN strings and parse them
      for(var line of input.replace(/\r\n/g, '\n').replace(/\s*;\s*/g, '\n').split('\n')) {
        line = line.trim();
        if(line.startsWith('[') && line.endsWith(']') && !/\s/.exec(line)) {
          let [turn, l, t] = fenFuncs.fromFen(line, width, height, isTurnZero, isEvenTimeline);
          boardFuncs.setTurn(this.rawBoard, l, t, turn);
        }
      }
    }
    else if(!currentBoard) {
      var res = '';
      var firstBoard = this.rawBoardHistory[0];
      var isTurnZero = boardFuncs.isTurnZero(firstBoard);
      var isEvenTimeline = boardFuncs.isEvenTimeline(firstBoard);
      for(var l = 0;l < firstBoard.length;l++) {
        for(var t = 0;firstBoard[l] && t < firstBoard[l].length;t++) {
          if(firstBoard[l][t]) {
            res += fenFuncs.toFen(firstBoard[l][t], l, t, isTurnZero, isEvenTimeline) + '\n';
          }
        }
      }
      return res;
    }
    else {
      var res = '';
      var isTurnZero = boardFuncs.isTurnZero(this.rawBoard);
      var isEvenTimeline = boardFuncs.isEvenTimeline(this.rawBoard);
      for(var l = this.rawBoard.length - 1;l > 0;l--) {
        if(this.rawBoard[l] && l % 2 !== 0) {
          for(var t = 0;t < this.rawBoard[l].length;t++) {
            if(this.rawBoard[l][t]) {
              res += fenFuncs.toFen(this.rawBoard[l][t], l, t, isTurnZero, isEvenTimeline) + '\n';
            }
          }
        }
      }
      for(var l = 0;l < this.rawBoard.length;l++) {
        if(this.rawBoard[l] && l % 2 === 0) {
          for(var t = 0;t < this.rawBoard[l].length;t++) {
            if(this.rawBoard[l][t]) {
              res += fenFuncs.toFen(this.rawBoard[l][t], l, t, isTurnZero, isEvenTimeline) + '\n';
            }
          }
        }
      }
      return res;
    }
  }
  fenable(input) {
    try {
      var newInstance = this.copy();
      newInstance.fen(input);
      return true;
    }
    catch(err) { return false; }
  }
  pass() {
    if(!this.skipDetection) {
      if(this.inCheckmate) {
        throw 'Cannot submit, currently in checkmate.';
      }
      if(this.inStalemate) {
        throw 'Cannot submit, currently in stalemate.';
      }
    }
    mateFuncs.blankAction(this.rawBoard, this.rawAction);
    this.submit();
  }
  passable() {
    try {
      var newInstance = this.copy();
      newInstance.pass;
      return true;
    }
    catch(err) { return false; }
  }
  action(input) {
    var moves = convertFuncs.action(input, this.rawBoard, this.rawAction, this.rawPromotionPieces);
    for(var i = 0;i < moves.length;i++) {
      this.move(moves[i]);
    }
    this.submit();
  }
  actions(format = 'object', activeOnly = true, presentOnly = true, newActiveTimelinesOnly = true) {
    var isTurnZero = boardFuncs.isTurnZero(this.rawBoard);
    var actions = actionFuncs.actions(this.rawBoard, this.rawAction, activeOnly, presentOnly, newActiveTimelinesOnly, this.metadata.board, this.rawPromotionPieces);
    if(format === 'raw') { return actions; }
    if(format.includes('notation')) {
      var res = '';
      for(var i = 0;i < actions.length;i++) {
        if(this.skipDetection || this.actionable(actions[i])) {
          for(var j = 0;j < actions[i].length;j++) {
            res += notationFuncs.moveNotation(this.rawBoard, this.rawAction, actions[i][j], format.includes('short')).str + '\n';
          }
        }
      }
      return res;
    }
    if(format.includes('5dpgn')) {
      var res = '';
      for(var i = 0;i < actions.length;i++) {
        res += pgnFuncs.fromMove(
          actions[i],
          this.rawBoard,
          this.rawAction,
          '',
          format.includes('active'),
          format.includes('timeline'),
          format.includes('superphysical')
        ) + '\n';
      }
      return res;
    }
    res = [];
    for(var i = 0;i < actions.length;i++) {
      if(this.skipDetection || this.actionable(actions[i])) {
        res.push(parseFuncs.fromAction(this.rawBoard, this.rawAction, actions[i], isTurnZero));
      }
    }
    if(format === 'json') {
      return JSON.stringify(res);
    }
    return res;
  }
  actionable(input) {
    try {
      var newInstance = this.copy();
      newInstance.action(input);
      return true;
    }
    catch(err) { return false; }
  }
  move(input) {
    var move = convertFuncs.move(input, this.rawBoard, this.rawAction, this.rawPromotionPieces);
    if(!this.skipDetection) {
      if(!this.moveable(move)) {
        var pgnStr = 'Move is invalid and an error has occurred with this move: ' + move;
        console.error(pgnStr);
        throw pgnStr;
      }
    }
    this.rawMoveBuffer.push(move);
    boardFuncs.move(this.rawBoard, move);
  }
  moves(format = 'object', activeOnly = true, presentOnly = true, spatialOnly = false) {
    var isTurnZero = boardFuncs.isTurnZero(this.rawBoard);
    if(!this.skipDetection) {
      if(this.inCheckmate) { return []; }
      if(this.inStalemate) { return []; }
    }
    var moves = boardFuncs.moves(this.rawBoard, this.rawAction, activeOnly, presentOnly, spatialOnly, this.rawPromotionPieces);
    if(format === 'raw') { return moves; }
    if(format.includes('notation')) {
      var res = '';
      for(var i = 0;i < moves.length;i++) {
        res += notationFuncs.moveNotation(this.rawBoard, this.rawAction, moves[i], format.includes('short')).str + '\n';
      }
      return res;
    }
    if(format.includes('5dpgn')) {
      var res = '';
      for(var i = 0;i < moves.length;i++) {
        res += pgnFuncs.fromMove(
          moves[i],
          this.rawBoard,
          this.rawAction,
          '',
          format.includes('active'),
          format.includes('timeline'),
          format.includes('superphysical')
        ) + '\n';
      }
      return res;
    }
    res = [];
    for(var i = 0;i < moves.length;i++) {
      res.push(parseFuncs.fromMove(this.rawBoard, moves[i], isTurnZero));
    }
    if(format === 'json') {
      return JSON.stringify(res);
    }
    return res;
  }
  moveable(input, moveGen = []) {
    try {
      if(this.skipDetection) {
        return true;
      }
      var move = convertFuncs.move(input, this.rawBoard, this.rawAction, this.rawPromotionPieces);
      return validateFuncs.move(this.rawBoard, this.rawAction, move, moveGen, this.rawPromotionPieces);
    }
    catch(err) { return false; }
  }
  submit() {
    if(!this.skipDetection) {
      if(this.inCheckmate) {
        throw 'Cannot submit, currently in checkmate.';
      }
      if(this.inStalemate) {
        throw 'Cannot submit, currently in stalemate.';
      }
      if(this.inCheck) {
        throw 'Cannot submit, currently in check.';
      }
    }
    if(!this.submittable()) {
      throw 'Action is not complete, more moves are needed';
    }
    this.rawBoardHistory.push(boardFuncs.copy(this.rawBoard));
    this.rawActionHistory.push(copyFuncs.action(this.rawMoveBuffer));
    this.rawMoveBuffer = [];
    this.rawAction++;
  }
  submittable() {
    if(!this.skipDetection) {
      if(this.inCheckmate) { return false; }
      if(this.inStalemate) { return false; }
    }
    if(this.inCheck) { return false; }
    return boardFuncs.present(this.rawBoard, this.rawAction).length <= 0;
  }
  undo() {
    if(this.rawMoveBuffer.length > 0) {
      var tmpBuffer = copyFuncs.action(this.rawMoveBuffer);
      tmpBuffer.pop();
      var tmpBoard = boardFuncs.copy(this.rawBoardHistory[this.rawBoardHistory.length - 1]);
      for(var i = 0;i < tmpBuffer.length;i++) {
        if(!this.skipDetection) {
          if(!validateFuncs.move(tmpBoard, this.rawAction, tmpBuffer[i], [], this.rawPromotionPieces)) {
            var pgnStr = 'Undo buffer is corrupted and an error has occurred with this move: ' + pgnFuncs.fromMove(tmpBuffer[i], tmpBoard, this.rawAction);
            console.error(pgnStr);
            throw pgnStr;
          }
        }
        boardFuncs.move(tmpBoard, tmpBuffer[i]);
      }
      this.rawBoard = boardFuncs.copy(tmpBoard);
      this.rawMoveBuffer = copyFuncs.action(tmpBuffer);
    }
    else {
      throw 'No moves to undo.';
    }
  }
  undoable() {
    try {
      this.copy().undo();
      return true;
    }
    catch(err) { return false; }
  }
  checks(format = 'object') {
    var isTurnZero = boardFuncs.isTurnZero(this.rawBoard);
    var checks = mateFuncs.checks(this.rawBoard, this.rawAction, false);
    var tmpBoard = boardFuncs.copy(this.rawBoard);
    mateFuncs.blankAction(tmpBoard, this.rawAction);
    if(format === 'raw') { return checks; }
    if(format.includes('notation')) {
      var res = '';
      for(var i = 0;i < checks.length;i++) {
        res += notationFuncs.moveNotation(tmpBoard, this.rawAction, checks[i], format.includes('short')).str + '\n';
      }
      return res;
    }
    if(format.includes('5dpgn')) {
      var res = '';
      for(var i = 0;i < checks.length;i++) {
        res += pgnFuncs.fromMove(
          checks[i],
          tmpBoard,
          this.rawAction,
          format.includes('active'),
          format.includes('timeline'),
          format.includes('superphysical')
        ) + '\n';
      }
      return res;
    }
    var res = [];
    for(var i = 0;i < checks.length;i++) {
      res.push(parseFuncs.fromMove(tmpBoard, checks[i], isTurnZero));
    }
    if(format === 'json') {
      return JSON.stringify(res);
    }
    return res;
  }
  get inCheckmate() {
    var latestBoard = this.rawBoardHistory[this.rawBoardHistory.length - 1];
    var hash = hashFuncs.hash(latestBoard);
    for(var i = 0;i < this.checkmateCache.length;i++) {
      if(hash === this.checkmateCache[i]) {
        return true;
      }
    }
    var res = mateFuncs.checkmate(latestBoard, this.rawAction, this.checkmateTimeout);
    if(res[0] && !res[1]) {
      this.checkmateCache.push(hash);
    }
    return res[0];
  }
  get inCheck() {
    return mateFuncs.checks(this.rawBoard, this.rawAction, true);
  }
  get inStalemate() {
    var latestBoard = this.rawBoardHistory[this.rawBoardHistory.length - 1];
    return mateFuncs.stalemate(latestBoard, this.rawAction, this.checkmateTimeout)[0];
  }
  get hash() {
    return md5(this.fen(null, true).replace(/\n/g,''));
  }
  export(format = '5dpgn') {
    var board = this.rawBoard;
    var isTurnZero = boardFuncs.isTurnZero(board);
    if(format === 'raw') { return this.rawActionHistory; }
    if(format === 'json') { return JSON.stringify(this.rawActionHistory.map((e,i) => {
      return parseFuncs.fromAction(this.rawBoardHistory[i], i, e, isTurnZero);
    })); }
    if(format === 'object') { return this.rawActionHistory.map((e,i) => {
      return parseFuncs.fromAction(this.rawBoardHistory[i], i, e, isTurnZero);
    }); }
    var res = '';
    res += metadataFuncs.objToStr(this.metadata);
    if(format.includes('notation')) {
      var tmpBoard = boardFuncs.copy(boardFuncs.init(this.metadata.board));
      for(var i = 0;i < this.rawActionHistory.length;i++) {
        for(var j = 0;j < this.rawActionHistory[i].length;j++) {
          var currMove = this.rawActionHistory[i][j];
          res += notationFuncs.moveNotation(tmpBoard, i, currMove, format.includes('short')).str + '\n';
          boardFuncs.move(tmpBoard, currMove);
        }
      }
    }
    if(format.includes('5dpgn')) {
      if(this.metadata.board === 'custom') {
        res += this.fen();
      }
      var suffixArr = []; //TODO implement check, checkmate, softmate
      res += pgnFuncs.fromActionHistory(
        this.rawActionHistory,
        this.rawBoardHistory[0],
        this.rawStartingAction,
        format.includes('inline') ? ' ' : '\n',
        suffixArr,
        format.includes('active'),
        format.includes('timeline'),
        format.includes('superphysical')
      );
    }
    return res;
  }
  print() {
    console.log('Current Player: ' + (this.rawAction % 2 === 0 ? 'White' : 'Black'));
    console.log('Action Number: ' + (Math.ceil(this.rawAction/2) + 1));
    if(this.rawMoveBuffer.length > 0) {
      console.log('Move Stack:');
    }
    for(var i = 0;i < this.rawMoveBuffer.length;i++) {
      console.log('  ' + pgnFuncs.fromMove(this.rawMoveBuffer[i], this.rawBoard, this.rawAction));
    }
    console.log(printFuncs.printBoard(this.rawBoard));
  }
  get board() {
    return parseFuncs.fromBoard(this.rawBoard, this.rawAction);
  }
  get actionNumber() {
    return Math.floor(this.rawAction/2) + 1;
  }
  get boardHistory() {
    var res = [];
    for(var i = 0;i < this.rawBoardHistory.length;i++) {
      res.push(parseFuncs.fromBoard(this.rawBoardHistory[i], i));
    }
    return res;
  }
  get actionHistory() {
    return this.export('object');
  }
  get moveBuffer() {
    var res = [];
    var board = this.rawBoard;
    var isTurnZero = boardFuncs.isTurnZero(this.rawBoard);
    var tmpBoard = boardFuncs.copy(this.rawBoardHistory[this.rawBoardHistory.length - 1]);
    for(var i = 0;i < this.rawMoveBuffer.length;i++) {
      res.push(parseFuncs.fromMove(tmpBoard, this.rawMoveBuffer[i], isTurnZero));
      boardFuncs.move(tmpBoard, this.rawMoveBuffer[i]);
    }
    return res;
  }
  get player() {
    return (this.rawAction % 2 === 0 ? 'white' : 'black');
  }
  get variants() {
    return metadataFuncs.variantDict.map(v => {
      return {
        name: v[0],
        shortName: v[1]
      };
    });
  }
}

module.exports = Chess;

},{"./action":4,"./board":5,"./convert":6,"./copy":7,"./fen":8,"./hash":9,"./mate":11,"./metadata":12,"./notation":13,"./parse":14,"./pgn":15,"./piece":16,"./print":17,"./turn":18,"./validate":19,"blueimp-md5":1,"module-alias/register":2}],11:[function(require,module,exports){
const present = require('present');
const boardFuncs = require('./board');
const turnFuncs = require('./turn');

exports.blankAction = (board, actionNum) => {
  var presentTimelines = boardFuncs.present(board, actionNum);
  for(var i = 0;i < presentTimelines.length;i++) {
    if(board[presentTimelines[i]]) {
      var currTimeline = board[presentTimelines[i]];
      var latestTurn = currTimeline[currTimeline.length - 1];
      if((currTimeline.length - 1) % 2 === actionNum % 2) {
        var newTurn = turnFuncs.copy(board, presentTimelines[i], currTimeline.length - 1);
        board[presentTimelines[i]][currTimeline.length] = newTurn;
      }
    }
  }
}

exports.checks = (board, actionNum, detectionOnly = false) => {
  var res = [];
  var tmpBoard = boardFuncs.copy(board);
  this.blankAction(tmpBoard, actionNum);
  var moves = boardFuncs.moves(tmpBoard, actionNum + 1, false, false);
  for(var i = 0;i < moves.length;i++) {
    if(moves[i].length === 2 && boardFuncs.positionExists(tmpBoard, moves[i][1])) {
      var destPiece = tmpBoard[moves[i][1][0]][moves[i][1][1]][moves[i][1][2]][moves[i][1][3]];
      if(
        (
          Math.abs(destPiece) === 11 || Math.abs(destPiece) === 12 // King
          || Math.abs(destPiece) === 19 || Math.abs(destPiece) === 20 // Royal queen
        ) && Math.abs(destPiece) % 2 === actionNum % 2
      ) {
        if(detectionOnly) { return true; }
        res.push(moves[i]);
      }
    }
  }
  if(detectionOnly) { return false; }
  return res;
}

exports.checkmate = (board, actionNum, maxTime = 60000) => {
  var inCheck = this.checks(board, actionNum, true);
  if(!inCheck) {
    return [false, false];
  }
  var start = present();

  // Super fast single pass looking for moves solving checks
  var moves = boardFuncs.moves(board, actionNum, false, false);
  for(var i = 0;i < moves.length;i++) {
    var tmpBoard = boardFuncs.copy(board);
    boardFuncs.move(tmpBoard, moves[i]);
    var inCheck = this.checks(tmpBoard, actionNum, true);
    if(!inCheck) { return [false, false]; }
    if((present() - start) > maxTime) { return [true, true]; }
  }
  // Fast pass looking for moves solving checks using DFS
  var recurse = (board, actionNum, checks = []) => {
    var moves = boardFuncs.moves(board, actionNum, false, false);
    if(checks.length <= 0) { checks = this.checks(board, actionNum); }
    if(checks.length <= 0) { return [false, false]; }
    if((present() - start) > maxTime) { return [true, true]; }
    for(var i = 0;i < moves.length;i++) {
      var tmpBoard = boardFuncs.copy(board);
      boardFuncs.move(tmpBoard, moves[i]);
      var tmpChecks = this.checks(tmpBoard, actionNum);
      var solvedACheck = tmpChecks.length < checks.length;
      if(solvedACheck) {
        if(!recurse(tmpBoard, actionNum, tmpChecks)[0]) {
          return [false, false];
        }
      }
    }
    return [true, false];
  }
  var r = recurse(board, actionNum);
  if(!r[0] || r[1]) { return r; }

  var checkSig = (checks) => {
    var res = {
      length: checks.length,
      sig: []
    };
    checks.sort(this.moveCompare);
    res.sig = checks.flat(2);
    return res;
  };
  var nodeSort = (n1, n2) => {
    if(n1.checkSig.length !== n2.checkSig.length) {
      return n1.checkSig.length - n2.checkSig.length;
    }
    if(n1.checkSig.sig.length !== n2.checkSig.sig.length) {
      return n1.checkSig.sig.length - n2.checkSig.sig.length;
    }
    for(var i = 0;i < n1.checkSig.sig.length;i++) {
      if(n1.checkSig.sig[i] !== n2.checkSig.sig[i]) {
        return n1.checkSig.sig[i] - n2.checkSig.sig[i];
      }
    }
    return n1.board.length - n2.board.length;
  };

  var exhausted = false;
  var moveTree = [{
    board: board,
    checkSig: checkSig(this.checks(board, actionNum))
  }];
  var moveTreeIndex = 0;
  //Slow BFS exhaustive search prioritizing check solving, check changing, then timeline changing moves
  while(moveTreeIndex < moveTree.length) {
    if((present() - start) > maxTime) { return [true, true]; }
    var currNode = moveTree[moveTreeIndex];
    if(currNode) {
      var moves = boardFuncs.moves(currNode, actionNum, false, false);
      var tmpMoveTree = [];
      for(var i = 0;i < moves.length;i++) {
        var tmpBoard = boardFuncs.copy(currNode);
        boardFuncs.move(tmpBoard, moves[i]);
        var tmpChecks = this.checks(tmpBoard, actionNum);
        if(tmpChecks.length <= 0) { return [false, false]; }
        var tmpCheckSig = checkSig(tmpChecks);
        tmpMoveTree.push({
          board: tmpBoard,
          checkSig: tmpCheckSig
        });
      }
      tmpMoveTree.sort((e1, e2) => nodeSort(currNode, e2) - nodeSort(currNode, e1));
      for(var i = 0;i < tmpMoveTree.length;i++) {
        moveTree.push(tmpMoveTree[i]);
      }
      moveTree.splice(0, 1);
      moveTreeIndex--;
    }
    moveTreeIndex++;
  }
  return [true, false];
}

exports.stalemate = (board, actionNum, maxTime = 60000) => {
  //TODO: Add stalemate testing
  var inCheck = this.checks(board, actionNum, true);
  if(inCheck) {
    return [false, false];
  }
  var start = present();

  var moveTree = [board];
  //DFS search for valid action
  while(moveTree.length > 0) {
    if((present() - start) > maxTime) { return [true, true]; }
    var currNode = moveTree[0];
    if(currNode) {
      var moves = boardFuncs.moves(currNode, actionNum, false, false);
      for(var i = 0;i < moves.length;i++) {
        var tmpBoard = boardFuncs.copy(currNode);
        boardFuncs.move(tmpBoard, moves[i]);
        var inCheck = this.checks(tmpBoard, actionNum, true);
        if(!inCheck) {
          var presentTimelines = boardFuncs.present(tmpBoard, actionNum);
          if(presentTimelines.length <= 0) {
            return [false, false];
          }
          moveTree.push(tmpBoard);
        }
      }
    }
    moveTree.splice(0, 1);
  }
  return [true, false];
}

exports.moveCompare = (move1, move2) => {
  if(Array.isArray(move1)) {
    if(Array.isArray(move2)) {
      if(move1.length === move2.length) {
        for(var i = 0;i < move1.length;i++) {
          if(move1[i].length === move2[i].length) {
            for(var j = 0;j < move1[i].length;j++) {
              if(move1[i][j] !== move2[i][j]) {
                return move1[i][j] - move2[i][j];
              }
            }
          }
          else {
            return move1[i].length - move2[i].length;
          }
        }
      }
      else {
        return move1.length - move2.length;
      }
    }
    else {
      return -1;
    }
  }
  else {
    if(Array.isArray(move2)) {
      return 1;
    }
    else {
      return 0;
    }
  }
  return 0;
}

},{"./board":5,"./turn":18,"present":3}],12:[function(require,module,exports){
exports.strToObj = (str) => {
  var obj = {};
  var strArr = str.replace(/\r\n/g, '\n').replace(/\]\[/g, ']\n[').split('\n');
  for(var i = 0;i < strArr.length;i++) {
    var regex = strArr[i].match(/\[([^\s]+)\s+\"([^\"]*)\"\]/);
    if(regex !== null) {
      obj[regex[1].toLowerCase()] = regex[2];
      if(regex[1].toLowerCase() === 'board') {
        obj[regex[1].toLowerCase()] = this.lookupVariant(regex[2]);
      }
      try {
        var tmp = JSON.parse(regex[2]);
        obj[regex[1].toLowerCase()] = tmp;
      }
      catch(err) {}
    }
  }
  return obj;
}

exports.objToStr = (obj) => {
  var str = '';
  var objArr = Object.keys(obj);
  for(var i = 0;i < objArr.length;i++) {
    if(typeof obj[objArr[i]] === 'object') {
      str += '[' + objArr[i].charAt(0).toUpperCase() + objArr[i].substr(1) + ' \"' + JSON.stringify(obj[objArr[i]]).replace(/\"/g, '\'') + '\"]\n';
    }
    else if(objArr[i] === 'board') {
      str += '[' + objArr[i].charAt(0).toUpperCase() + objArr[i].substr(1) + ' \"' + this.lookupVariantFull(obj[objArr[i]]) + '\"]\n';
    }
    else {
      str += '[' + objArr[i].charAt(0).toUpperCase() + objArr[i].substr(1) + ' \"' + obj[objArr[i]] + '\"]\n';
    }
  }
  return str;
}

const variantDict = [
  ['Standard', 'standard'],
  ['Standard - Defended Pawn', 'defended_pawn'],
  ['Standard - Half Reflected', 'half_reflected'],
  ['Standard - Princess', 'princess'],
  ['Standard - Turn Zero', 'turn_zero'],
  ['Standard - Two Timelines', 'two_timelines'],
  ['Standard - Reversed Royalty', 'reversed_royalty'],
  ['Custom', 'custom']
]

exports.lookupVariant = (variantPrettyStr) => {
  //More lenient input since its used frequently in front facing application.
  for(var i = 0;i < variantDict.length;i++) {
    if(variantDict[i][0].toLocaleLowerCase().includes(variantPrettyStr.toLocaleLowerCase().replace(/_/g, ' '))) {
      return variantDict[i][1];
    }
    if(variantDict[i][1] === this.lookupVariantFull(variantPrettyStr) && variantDict[i][1] !== 'Standard') {
      return variantDict[i][1];
    }
  }
  return 'standard';
}

exports.lookupVariantFull = (variantStr) => {
  for(var i = 0;i < variantDict.length;i++) {
    if(variantDict[i][1] === variantStr) {
      return variantDict[i][0];
    }
  }
  return 'Standard';
}

exports.variantDict = variantDict;
},{}],13:[function(require,module,exports){
const boardFuncs = require('./board');
const mateFuncs = require('./mate');
const pieceFuncs = require('./piece');

exports.sanCoord = (input) => {
  var res = {
    str: '',
    arr: [0,0]
  };
  if(typeof input === 'string') {
    res.str = input;
    res.arr[1] = input.charCodeAt(0) - 97;
    res.arr[0] = Number(input.charAt(1)) - 1;
  }
  else if(Array.isArray(input)) {
    res.str = String.fromCharCode(input[1] + 97) + (input[0] + 1);
    res.arr = input;
  }
  return res;
}

exports.moveNotation = (board, actionNum, input, minimize = false) => {
  //(Action #)(Color). [Turn #][+/- Line #]:(Piece)[Coord]<[+/- New Line #]>[Dest Turn #][Dest +/- Line #]:[Capture][Promotion Piece][Dest Coord][Check][En Passant]
  var res = {
    str: '',
    arr: [[0,0,0,0],[0,0,0,0]],
    action: actionNum
  };
  if(typeof input === 'string') {
    res.str = input;
    var tmp = input.slice();
    var tmpActionArr = tmp.match(/^\d+[bw]/);
    if(tmpActionArr && tmpActionArr.length > 0) {
      var tmpAction = tmpActionArr[0];
      res.action = (Number(tmpAction.substr(0,tmpAction.length - 1)) - 1) * 2 + (tmpAction.charAt(tmpAction.length - 1) === 'w' ? 0 : 1);
    }
    tmp = tmp.replace(/^\d+[bw]\.\s+/, '');
    var tmpSrcTurnArr = tmp.match(/^\d+/);
    if(tmpSrcTurnArr && tmpSrcTurnArr.length > 0) {
      var tmpSrcTurn = Number(tmpSrcTurnArr[0]);
      res.arr[0][1] = (tmpSrcTurn - 1) * 2 + (res.action % 2 === 0 ? 0 : 1);
      tmp = tmp.replace(/^\d+/, '');
    }
    var tmpSrcTimelineArr = tmp.match(/^[\-\+]\d+/);
    if(tmpSrcTimelineArr && tmpSrcTimelineArr.length > 0) {
      var tmpSrcTimeline = Number(tmpSrcTimelineArr[0]);
      res.arr[0][0] = Math.abs(tmpSrcTimeline) * 2 + (tmpSrcTimeline < 0 ? -1 : 0);
      tmp = tmp.replace(/^[\-\+]\d+/, '');
    }
    tmp = tmp.substr(1);
    if(!tmp.includes('0-0')) {
      tmp = tmp.replace(/^[A-Z]/, '');
      var tmpSrcCoord = this.sanCoord(tmp.substr(0,2));
      res.arr[0][2] = tmpSrcCoord.arr[0];
      res.arr[0][3] = tmpSrcCoord.arr[1];
      tmp = tmp.substr(2);
      if(tmp.charAt(0) === '<') {
        tmp = tmp.replace(/^\<[\-\+]*\d*\>/, '');
        var tmpDestTurnArr = tmp.match(/^\d+/);
        if(tmpDestTurnArr && tmpDestTurnArr.length > 0) {
          var tmpDestTurn = Number(tmpDestTurnArr[0]);
          res.arr[1][1] = (tmpDestTurn - 1) * 2 + (res.action % 2 === 0 ? 0 : 1);
          tmp = tmp.replace(/^\d+/, '');
        }
        else {
          res.arr[1][1] = res.arr[0][1];
        }
        var tmpDestTimelineArr = tmp.match(/^[\-\+]\d+/);
        if(tmpDestTimelineArr && tmpDestTimelineArr.length > 0) {
          var tmpDestTimeline = Number(tmpDestTimelineArr[0]);
          res.arr[1][0] = Math.abs(tmpDestTimeline) * 2 + (tmpDestTimeline < 0 ? -1 : 0);
          tmp = tmp.replace(/^[\-\+]\d+/, '');
        }
        else {
          res.arr[1][0] = res.arr[0][0];
        }
      }
      else {
        res.arr[1][0] = res.arr[0][0];
        res.arr[1][1] = res.arr[0][1];
      }
      tmp = tmp.substr(1);
      tmp = tmp.replace(/^x*/, '');
      var tmpDestPieceArr = tmp.match(/^[A-Z]*/);
      if(tmpDestPieceArr && tmpDestPieceArr.length > 0) {
        var tmpDestPiece = tmpDestPieceArr[0];
        if(tmpDestPiece === 'B') {
          res.arr[1][4] = (res.action % 2 === 0 ? 4 : 3);
        }
        if(tmpDestPiece === 'N') {
          res.arr[1][4] = (res.action % 2 === 0 ? 6 : 5);
        }
        if(tmpDestPiece === 'R') {
          res.arr[1][4] = (res.action % 2 === 0 ? 8 : 7);
        }
        if(tmpDestPiece === 'Q') {
          res.arr[1][4] = (res.action % 2 === 0 ? 10 : 9);
        }
        if(tmpDestPiece === 'K') {
          res.arr[1][4] = (res.action % 2 === 0 ? 12 : 11);
        }
        if(tmpDestPiece === 'P') {
          res.arr[1][4] = (res.action % 2 === 0 ? 14 : 13);
        }
        tmp = tmp.replace(/^[A-Z]*/, '');
      }
      var tmpDestCoord = this.sanCoord(tmp.substr(0,2));
      res.arr[1][2] = tmpDestCoord.arr[0];
      res.arr[1][3] = tmpDestCoord.arr[1];
      tmp = tmp.substr(2);
      if(tmp.includes('e.p.')) {
        res.arr[2] = [];
        res.arr[2][0] = res.arr[0][0];
        res.arr[2][1] = res.arr[0][1];
        res.arr[2][2] = res.arr[0][2];
        res.arr[2][3] = res.arr[1][3];
      }
    }
    else {
      res.arr[2] = [];
      res.arr[3] = [];
      res.arr[1][0] = res.arr[0][0];
      res.arr[2][0] = res.arr[0][0];
      res.arr[3][0] = res.arr[0][0];
      res.arr[1][1] = res.arr[0][1];
      res.arr[2][1] = res.arr[0][1];
      res.arr[3][1] = res.arr[0][1];
      res.arr[0][3] = 4;
      if(res.action % 2 !== 0) {
        res.arr[0][2] = 7;
        res.arr[1][2] = res.arr[0][2];
        res.arr[2][2] = res.arr[0][2];
        res.arr[3][2] = res.arr[0][2];
      }
      else {
        res.arr[0][2] = 0;
        res.arr[1][2] = res.arr[0][2];
        res.arr[2][2] = res.arr[0][2];
        res.arr[3][2] = res.arr[0][2];
      }
      if(tmp.includes('0-0-0')) {
        res.arr[1][3] = 2;
        res.arr[2][3] = 0;
        res.arr[3][3] = 3;
      }
      else {
        res.arr[1][3] = 6;
        res.arr[2][3] = 7;
        res.arr[3][3] = 5;
      }
    }
  }
  else if(Array.isArray(input)) {
    res.arr = [input[0].slice(),input[1].slice()];
    if(input[2]) {
      res.arr[2] = input[2].slice();
    }
    if(input[3]) {
      res.arr[3] = input[3].slice();
    }
    res.str += Math.ceil((res.action+1)/2) + (res.action % 2 === 0 ? 'w' : 'b');
    res.str += '. ';
    res.str += Math.ceil((input[0][1]+1)/2);
    if(input[0][0] !== 0) {
      if(input[0][0] % 2 === 0) {
        res.str += '+' + Math.ceil(input[0][0]/2);
      }
      else {
        res.str += '-' + Math.ceil(input[0][0]/2);
      }
    }
    res.str += ':';
    if(input.length === 2 || input.length === 3) {
      if(boardFuncs.positionExists(board, input[0])) {
        var piece = board[input[0][0]][input[0][1]][input[0][2]][input[0][3]];
        res.str += pieceFuncs.toChar(piece);
        res.str += this.sanCoord([input[0][2],input[0][3]]).str;
        if(
          ((input[0][1] === input[1][1] && !minimize) || input[0][1] !== input[1][1]) ||
          ((input[0][0] === input[1][0] && !minimize) || input[0][0] !== input[1][0])
        ) {
          res.str += '<';
          var maxTimeline = 0;
          for(var i = 0;i < board.length;i++) {
            if(board[i] !== undefined && i % 2 === res.action % 2) { maxTimeline = i; }
          }
          var moddedBoard = boardFuncs.copy(board);
          boardFuncs.move(moddedBoard, input);
          var newMaxTimeline = 0;
          for(var i = 0;i < moddedBoard.length;i++) {
            if(moddedBoard[i] !== undefined && i % 2 === res.action % 2) { newMaxTimeline = i; }
          }
          if(maxTimeline !== newMaxTimeline) {
            if(newMaxTimeline % 2 === 0) {
              res.str += '+' + Math.ceil(newMaxTimeline/2);
            }
            else {
              res.str += '-' + Math.ceil(newMaxTimeline/2);
            }
          }
          res.str += '>';
        }
        if((input[0][1] === input[1][1] && !minimize) || input[0][1] !== input[1][1]) {
          res.str += Math.ceil((input[1][1]+1)/2);
        }
        if((input[0][0] === input[1][0] && !minimize) || input[0][0] !== input[1][0]) {
          if(input[1][0] !== 0) {
            if(input[1][0] % 2 === 0) {
              res.str += '+' + Math.ceil(input[1][0]/2);
            }
            else {
              res.str += '-' + Math.ceil(input[1][0]/2);
            }
          }
          else if(input[0][0] !== input[1][0]) {
            res.str += '+0';
          }
        }
        res.str += ':';
        var destPiece = board[input[1][0]][input[1][1]][input[1][2]][input[1][3]];
        if((destPiece !== 0 && Math.abs(piece) % 2 !== Math.abs(destPiece) % 2) || input.length === 3) {
          res.str += 'x';
        }
        if(input[1][4] !== undefined) {
          var srcPiece = board[input[0][0]][input[0][1]][input[0][2]][input[0][3]];
          if(Math.abs(srcPiece) === 1 || Math.abs(srcPiece) === 2) {
            res.str += pieceFuncs.toChar(input[1][4]);
          }
        }
        res.str += this.sanCoord([input[1][2],input[1][3]]).str;
        if(input.length === 3) {
          res.str += 'e.p.';
        }
        if(mateFuncs.stalemate(moddedBoard, res.action + 1)[0]) {
          res.str += '=';
        }
        else if(mateFuncs.checkmate(moddedBoard, res.action + 1)[0]) {
          res.str += '#';
        }
        else if(mateFuncs.checks(moddedBoard, res.action + 1).length > 0) {
          res.str += '+';
        }
      }
    }
    else if(input.length === 4) {
      res.str += '0-0';
      if(input[1][3] === 2) {
        res.str += '-0';
      }
    }
  }
  return res;
}

},{"./board":5,"./mate":11,"./piece":16}],14:[function(require,module,exports){
const boardFuncs = require('./board');
const pgnFuncs = require('./pgn');
const pieceFuncs = require('./piece');

exports.toPosition = (positionObj, isTurnZero = false) => {
  var res = [];
  if(positionObj.timeline >= 0) {
    res[0] = (positionObj.timeline*2);
  }
  else if(positionObj.timeline < 0) {
    res[0] = ((-positionObj.timeline)*2) - 1;
  }
  var currTurn = positionObj.turn;
  if(isTurnZero) {
    currTurn++;
  }
  res[1] = ((currTurn - 1) * 2) + (positionObj.player === 'white' ? 0 : 1);
  res[2] = positionObj.rank - 1;
  res[3] = positionObj.file - 1;
  return res;
}

exports.fromPosition = (position, isTurnZero = false) => {
  var res = {};
  if(position[0] === 0) {
    res.timeline = 0;
  }
  else if(position[0] % 2 === 0) {
    res.timeline = Math.ceil(position[0]/2);
  }
  else {
    res.timeline = -Math.ceil(position[0]/2);
  }
  res.turn = Math.floor(position[1]/2) + 1;
  if(isTurnZero) {
    res.turn--;
  }
  res.player = (position[1] % 2 === 0 ? 'white' : 'black');
  res.coordinate = pgnFuncs.toSanCoord([position[2], position[3]]);
  res.rank = position[2] + 1;
  res.file = position[3] + 1;
  return res;
}

exports.toMove = (moveObj, isTurnZero = false) => {
  var res = [];
  res[0] = this.toPosition(moveObj.start, isTurnZero);
  res[1] = this.toPosition(moveObj.end, isTurnZero);
  if(moveObj.promotion !== null) {
    res[1][4] = pieceFuncs.fromChar(moveObj.promotion, moveObj.player === 'white' ? 0 : 1);
  }
  if(moveObj.enPassant !== null) {
    res[2] = this.toPosition(moveObj.enPassant, isTurnZero);
  }
  if(moveObj.castling !== null) {
    res[2] = this.toPosition(moveObj.castling.start, isTurnZero);
    res[3] = this.toPosition(moveObj.castling.end, isTurnZero);
  }
  return res;
}

exports.fromMove = (board, move, isTurnZero = false) => {
  var res = {
    promotion: null,
    enPassant: null,
    castling: null
  };
  res.start = this.fromPosition(move[0], isTurnZero);
  res.end = this.fromPosition(move[1], isTurnZero);
  res.player = (move[0][1] % 2 === 0 ? 'white' : 'black');
  if(move[1][4] !== undefined && move.length === 2) {
    res.promotion = pieceFuncs.toChar(move[1][4]);
  }
  if(move.length === 3) {
    res.enPassant = this.fromPosition(move[2], isTurnZero);
  }
  if(move.length === 4) {
    var realEnd = move[3].slice();
    realEnd[1] = realEnd[1] + 1;
    res.castling = {
      start: this.fromPosition(move[2], isTurnZero),
      end: this.fromPosition(move[3], isTurnZero),
      realEnd: this.fromPosition(realEnd, isTurnZero)
    }
  }

  //Calculating real end position
  var currMinT = 0;
  var currMaxT = 0;
  var newMinT = 0;
  var newMaxT = 0;
  var tmpBoard = boardFuncs.copy(board);
  try {
    for(var i = 0;i < tmpBoard.length;i++) {
      if(typeof tmpBoard[i] !== 'undefined' && tmpBoard[i] !== null) {
        if(i % 2 === 0) {
          currMaxT = i;
        }
        else {
          currMinT = i;
        }
      }
    }
    boardFuncs.move(tmpBoard, move);
    for(var i = 0;i < tmpBoard.length;i++) {
      if(typeof tmpBoard[i] !== 'undefined' && tmpBoard[i] !== null) {
        if(i % 2 === 0) {
          newMaxT = i;
        }
        else {
          newMinT = i;
        }
      }
    }
  }
  catch(err) {}
  var realEnd = move[1].slice();
  realEnd[1] = realEnd[1] + 1;
  if(currMinT !== newMinT) {
    realEnd[0] = newMinT;
  }
  else if(currMaxT !== newMaxT) {
    realEnd[0] = newMaxT;
  }
  res.realEnd = this.fromPosition(realEnd, isTurnZero);
  return res;
}

exports.toAction = (actionObj, isTurnZero = false) => {
  var res = [];
  for(var i = 0;i < actionObj.moves.length;i++) {
    res.push(this.toMove(actionObj.moves[i], isTurnZero));
  }
  return res;
}

exports.fromAction = (board, actionNum, moves, isTurnZero = false) => {
  var res = {};
  res.action = Math.floor(actionNum/2) + 1;
  res.player = (actionNum % 2 === 0 ? 'white' : 'black');
  res.moves = [];
  var tmpBoard = boardFuncs.copy(board);
  for(var i = 0;i < moves.length;i++) {
    res.moves.push(this.fromMove(tmpBoard, moves[i], isTurnZero));
    boardFuncs.move(tmpBoard, moves[i]);
  }
  return res;
}

exports.toPiece = (pieceObj) => {
  var res = pieceFuncs.fromChar(pieceObj.piece, (pieceObj.player === 'white' ? 0 : 1));
  if(pieceObj.hasMoved === false) {
    res = -res;
  }
  return res;
}

exports.fromPiece = (board, pos, isTurnZero = false) => {
  var res = {};
  var piece = board[pos[0]][pos[1]][pos[2]][pos[3]];
  res.position = this.fromPosition(pos, isTurnZero);
  res.piece = pieceFuncs.toChar(piece);
  res.player = (Math.abs(piece) % 2 === 0 ? 'white' : 'black');
  res.hasMoved = piece > 0;
  return res;
}

exports.toTurn = (turnObj, isTurnZero = false) => {
  var res = [];
  for(var r = 0;r < turnObj.height;r++) {
    res.push([]);
    for(var f = 0;f < turnObj.width;f++) {
      res[r][f] = 0;
    }
  }
  for(var i = 0;i < turnObj.pieces.length;i++) {
    var piece = this.toPiece(turnObj.pieces[i]);
    var position = this.toPosition(turnObj.pieces[i].position, isTurnZero);
    res[position[2]][position[3]] = piece;
  }
  return res;
}

exports.fromTurn = (board, timeline, turn, isTurnZero = false) => {
  var res = {};
  res.turn = Math.floor(turn/2) + 1;
  if(isTurnZero) {
    res.turn--;
  }
  res.player = (turn % 2 === 0 ? 'white' : 'black');
  res.pieces = [];
  res.width = 0;
  var currTurn = board[timeline][turn];
  res.height = currTurn.length;
  for(var r = 0;r < currTurn.length;r++) {
    for(var f = 0;f < currTurn[r].length;f++) {
      if(currTurn[r][f] !== 0) {
        res.pieces.push(this.fromPiece(board, [
          timeline,
          turn,
          r,
          f
        ], isTurnZero));
      }
      if(res.width < currTurn[r].length) {
        res.width = currTurn[r].length;
      }
    }
  }
  return res;
}

exports.toTimeline = (timelineObj, isTurnZero = false) => {
  var res = [];
  var maxTurnNumber = 0;
  for(var i = 0;i < timelineObj.turns.length;i++) {
    var currTurnNumber = timelineObj.turns[i].turn;
    if(isTurnZero) {
      currTurnNumber++;
    }
    var newTurnNumber = ((currTurnNumber - 1) * 2) + (timelineObj.turns[i].player === 'white' ? 0 : 1);
    if(maxTurnNumber < newTurnNumber) {
      maxTurnNumber = newTurnNumber;
    }
  }
  for(var i = 0;i < maxTurnNumber;i++) {
    res[i] = null;
  }
  for(var i = 0;i < timelineObj.turns.length;i++) {
    var currTurnNumber = timelineObj.turns[i].turn;
    if(isTurnZero) {
      currTurnNumber++;
    }
    var newTurnNumber = ((currTurnNumber - 1) * 2) + (timelineObj.turns[i].player === 'white' ? 0 : 1);
    res[newTurnNumber] = this.toTurn(timelineObj.turns[i], isTurnZero);
  }
  return res;
}

exports.fromTimeline = (board, actionNum, timeline, isTurnZero = false) => {
  var res = {};
  if(timeline === 0) {
    res.timeline = 0;
  }
  else if(timeline % 2 === 0) {
    res.timeline = Math.ceil(timeline/2);
  }
  else {
    res.timeline = -Math.ceil(timeline/2);
  }
  res.player = (timeline % 2 === 0 ? 'white' : 'black');
  res.turns = [];
  res.active = boardFuncs.active(board).includes(timeline);
  res.present = boardFuncs.present(board, actionNum).includes(timeline);
  var currTimeline = board[timeline];
  for(var i = 0;i < currTimeline.length;i++) {
    if(!(typeof currTimeline[i] === 'undefined' || currTimeline[i] === null)) {
      res.turns.push(this.fromTurn(board, timeline, i, isTurnZero));
    }
  }
  return res;
}

exports.toBoard = (boardObj) => {
  var res = [];
  var isTurnZero = false;
  var maxTimelineNumber = 0;
  for(var i = 0;i < boardObj.timelines.length;i++) {
    for(var j = 0;j < boardObj.timelines[i].turns.length;j++) {
      if(boardObj.timelines[i].turns[j].turn === 0) {
        isTurnZero = true;
      }
    }
    var newTimelineNumber = (boardObj.timelines[i].timeline*2);
    if(boardObj.timelines[i].timeline < 0) {
      newTimelineNumber = ((-boardObj.timelines[i].timeline.timeline)*2) - 1;
    }
    if(maxTimelineNumber < newTimelineNumber) {
      maxTimelineNumber = newTimelineNumber;
    }
  }
  for(var i = 0;i < maxTimelineNumber;i++) {
    res[i] = null;
  }
  for(var i = 0;i < boardObj.timelines.length;i++) {
    var newTimelineNumber = (boardObj.timelines[i].timeline*2);
    if(boardObj.timelines[i].timeline < 0) {
      newTimelineNumber = ((-boardObj.timelines[i].timeline)*2) - 1;
    }
    res[newTimelineNumber] = this.toTimeline(boardObj.timelines[i], isTurnZero);
  }
  return res;
}

exports.fromBoard = (board, actionNum) => {
  var res = {};
  var isTurnZero = boardFuncs.isTurnZero(board);
  res.action = Math.floor(actionNum/2) + 1;
  res.player = (actionNum % 2 === 0 ? 'white' : 'black');
  res.timelines = [];
  for(var i = 0;i < board.length;i++) {
    if(!(typeof board[i] === 'undefined' || board[i] === null)) {
      res.timelines.push(this.fromTimeline(board, actionNum, i, isTurnZero));
    }
  }
  res.width = 0;
  res.height = 0;
  for(var l = 0;l < res.timelines.length;l++) {
    for(var t = 0;t < res.timelines[l].turns.length;t++) {
      if(res.width < res.timelines[l].turns[t].width) {
        res.width = res.timelines[l].turns[t].width;
      }
      if(res.height < res.timelines[l].turns[t].height) {
        res.height = res.timelines[l].turns[t].height;
      }
    }
  }
  return res;
}

},{"./board":5,"./pgn":15,"./piece":16}],15:[function(require,module,exports){
const boardFuncs = require('./board');
const copyFuncs = require('./copy');
const parseFuncs = require('./parse');
const pieceFuncs = require('./piece');
const validateFuncs = require('./validate');
const { action } = require('./convert');

exports.toSanCoord = (point) => {
  return String.fromCharCode(point[1] + 97) + (point[0] + 1);
}

exports.fromSanCoord = (str) => {
  var match = str.match(/^([a-h]?)(\d?)/);
  return [
    match[2].length > 0 ?
      Number(match[2]) - 1
    :
      -1,
    match[1].length > 0 ?
      match[1].charCodeAt(0) - 97
    :
      -1
  ];
}

exports.ambiguousSan = (move, board, actionNum = 0, moveGen = [], promotionPieces = null) => {
  //moveGen here is for pregenerated moves (skipping generating moves again)
  var res = '';
  var moves = moveGen;
  if(moves.length <= 0) {
    moves = boardFuncs.moves(board, actionNum, false, false, promotionPieces);
  }
  var src = move[0];
  var dest = move[1];
  var piece = Math.abs(board[src[0]][src[1]][src[2]][src[3]]);
  var destPiece = board[dest[0]][dest[1]][dest[2]][dest[3]];
  var conflict = false;
  var sameRank = false;
  var sameFile = false;
  for(var i = 0;i < moves.length;i++) {
    if(validateFuncs.compareMove(move, moves[i]) !== 0) {
      if(moves[i].length <= 3) {
        var currSrc = moves[i][0];
        var currDest = moves[i][1];
        var currPiece = Math.abs(board[currSrc[0]][currSrc[1]][currSrc[2]][currSrc[3]]);
        if(piece === currPiece) {
          if(
            src[0] === currSrc[0] &&
            src[1] === currSrc[1] &&
            dest[0] === currDest[0] &&
            dest[1] === currDest[1] &&
            dest[2] === currDest[2] &&
            dest[3] === currDest[3]
          ) {
            if(src[2] === currSrc[2]) {
              sameRank = true;
            }
            if(src[3] === currSrc[3]) {
              sameFile = true;
            }
            conflict = true;
          }
        }
      }
    }
  }
  if(conflict) {
    if(!sameFile) {
      res += this.toSanCoord([src[2], src[3]])[0];
    }
    else if(sameFile && !sameRank) {
      res += this.toSanCoord([src[2], src[3]])[1];
    }
    else if(sameFile && sameRank) {
      res += this.toSanCoord([src[2], src[3]]);
    }
  }
  if(Math.abs(destPiece) !== 0 || move.length === 3) {
    if(Math.abs(piece) === 1 || Math.abs(piece) === 2) {
      if(!conflict) {
        res += this.toSanCoord([src[2], src[3]])[0];
      }
    }
    res += 'x';
  }
  res += this.toSanCoord([dest[2], dest[3]]);
  return res;
}

exports.fromMove = (move, board = [], actionNum = 0, suffix = '', timelineActivationToken = true, newTimelineToken = true, superPhysicalToken = false) => {
  var res = '';
  var src = move[0];
  var dest = move[1];
  var isTurnZero = boardFuncs.isTurnZero(board);
  var isEvenTimeline = boardFuncs.isEvenTimeline(board);
  var moveObj = parseFuncs.fromMove(board, move, isTurnZero);
  var isSingleTimeline = board.length <= 1;
  var isTimelineTravel = src[0] !== dest[0];
  var isTimeTravel = src[1] !== dest[1];
  //Checking if castling needs to be in O-O format
  var isNormalCastling = move.length === 4 && boardFuncs.isNormalCastling(board);
  var isEnPassant = move.length === 3;
  var isPromotion = dest.length >= 5;
  var isJump = (isTimelineTravel || isTimeTravel);
  var isBranching = false;
  var isPresentMoving = false;
  var newActivePresent = null;
  var newTimeline = null;
  if(isJump) {
    var tmpBoard = boardFuncs.copy(board);
    var excludeActive = null;
    var newActive = null;
    boardFuncs.move(tmpBoard, move);
    for(var i = 0;i < tmpBoard.length;i++) {
      if(Array.isArray(tmpBoard[i]) && !Array.isArray(board[i])) {
        isBranching = true;
        newTimeline = i % 2 === 0 ? Math.ceil(i/2) : -Math.ceil(i/2);
        excludeActive = i;
      }
    }
    var actives = boardFuncs.active(board);
    var tmpActives = boardFuncs.active(tmpBoard);
    for(var i = 0;i < tmpActives.length;i++) {
      if(!actives.includes(tmpActives[i]) && tmpActives[i] !== excludeActive) {
        newActive = tmpActives[i];
      }
    }
    if(newActive !== null && tmpBoard[newActive].length + 1 < tmpBoard[excludeActive].length) {
      newActivePresent = Math.floor((tmpBoard[newActive].length + 1) / 2);
    }
    if(tmpActives.includes(excludeActive)) {
      isPresentMoving = true;
    }
  }
  var srcSP = `(${moveObj.start.timeline}T${moveObj.start.turn})`;
  //Adjust the timeline field for even timelines
  if(isEvenTimeline) {
    if(moveObj.start.timeline < -1) {
      srcSP = `(${moveObj.start.timeline + 1}T${moveObj.start.turn})`;
    }
    else if(moveObj.start.timeline === -1) {
      srcSP = `(-0T${moveObj.start.turn})`;
    }
    else if(moveObj.start.timeline === 1) {
      srcSP = `(+0T${moveObj.start.turn})`;
    }
    else {
      srcSP = `(${moveObj.start.timeline - 1}T${moveObj.start.turn})`;
    }
  }
  var destSP = `(${moveObj.end.timeline}T${moveObj.end.turn})`;
  //Adjust the timeline field for even timelines
  if(isEvenTimeline) {
    if(moveObj.end.timeline < -1) {
      destSP = `(${moveObj.end.timeline + 1}T${moveObj.end.turn})`;
    }
    else if(moveObj.end.timeline === -1) {
      destSP = `(-0T${moveObj.end.turn})`;
    }
    else if(moveObj.end.timeline === 1) {
      destSP = `(+0T${moveObj.end.turn})`;
    }
    else {
      destSP = `(${moveObj.end.timeline - 1}T${moveObj.end.turn})`;
    }
  }
  var srcPiece = board[src[0]][src[1]][src[2]][src[3]];
  var destPiece = board[dest[0]][dest[1]][dest[2]][dest[3]];
  var isCapturing = Math.abs(destPiece) !== 0;
  var pieceChar = pieceFuncs.toChar(srcPiece, isJump);
  var promotionPieceChar = '';
  if(isPromotion) {
    promotionPieceChar = pieceFuncs.toChar(dest[4]);
  }
  //Notation construction
  if(isJump) {
    res += srcSP;
    res += pieceChar;
    res += this.toSanCoord([src[2], src[3]]);
    res += isBranching ? '>>' : '>';
    res += isCapturing ? 'x' : '';
    res += destSP;
    res += this.toSanCoord([dest[2], dest[3]]);
  }
  else {
    if(superPhysicalToken || !isSingleTimeline) {
      res += srcSP;
    }
    if(isNormalCastling) {
      res += 'O-O';
      if(Math.abs(move[2][3] - move[3][3]) > 2) {
        //Queenside
        res += '-O';
      }
    }
    else {
      res += pieceChar;
      res += this.ambiguousSan(move, board, actionNum, [], null);
    }
  }
  if(isPromotion) {
    res += `=${promotionPieceChar}`;
  }
  res += suffix;
  res += isPresentMoving ? '~' : '';
  if(timelineActivationToken && newActivePresent !== null) {
    res += ` (~T${newActivePresent})`;
  }
  if(newTimelineToken && newTimeline !== null) {
    res += ` (>L${newTimeline})`;
  }
  return res;
}

exports.toMove = (moveStr, board = [], actionNum = 0, moveGen = [], promotionPieces = null) => {
  //moveGen here is for pregenerated moves (skipping generating moves again)
  var res = [[0,0,-1,-1],[0,0,-1,-1]];
  //Remove tokens
  var orgMoveStr = moveStr;
  moveStr = moveStr.replace(/\r\n/g, '\n');
  moveStr = moveStr.replace(/\{[^\{\}]*\}/g, '');
  moveStr = moveStr.replace(/;[^;\n]*\n/g, '\n');
  moveStr = moveStr.replace(/\s/g, '');
  moveStr = moveStr.replace(/\(~T\-?\d*\)/g, '');
  moveStr = moveStr.replace(/\(>L\-?\d*\)/g, '');
  //Start move reconstruction
  var isJump = moveStr.includes('>');
  var isTurnZero = boardFuncs.isTurnZero(board);
  var isEvenTimeline = boardFuncs.isEvenTimeline(board);
  var piece = actionNum % 2 === 0 ? 2 : 1;
  if(isJump) {
    try {
      var srcSP = moveStr.match(/^\(L?\-?\+?\d+T\-?\+?\d+\)/)[0];
      moveStr = moveStr.replace(/^\(L?\-?\+?\d+T\-?\+?\d+\)/, '');
      srcSP = srcSP.replace(/L/g,'');
      var srcSPArr = srcSP.match(/\((\-?\+?\d*)T(\-?\+?\d*)\)/);
      var srcL = Number(srcSPArr[1]);
      //Adjust extracted timeline if in even timeline mode
      if(isEvenTimeline) {
        if(srcSPArr[1] === '-0') {
          srcL = -1;
        }
        else if(srcSPArr[1] === '+0') {
          srcL = 1;
        }
        else if(srcL < 0) {
          srcL--;
        }
        else if(srcL > 0) {
          srcL++;
        }
      }
      var srcT = Number(srcSPArr[2]);
      res[0][0] = Math.abs(srcL) * 2 + (srcL < 0 ? -1 : 0);
      res[0][1] = (srcT - 1) * 2 + (actionNum % 2 === 0 ? 0 : 1);
      if(isTurnZero) {
        res[0][1] += 2;
      }
    }
    catch(err) { throw 'Source super-physical coordinates missing or incorrect!'; }
    var pieceChar = moveStr.match(/^[A-Z]+/);
    if(pieceChar !== null) {
      piece = pieceFuncs.fromChar(pieceChar[0], actionNum);
    }
    moveStr = moveStr.replace(/^[A-Z]+/,'');
    var srcP = this.fromSanCoord(moveStr.match(/^[a-h]\d/)[0]);
    moveStr = moveStr.replace(/^[a-h]\d/,'');
    res[0][2] = srcP[0];
    res[0][3] = srcP[1];
    moveStr = moveStr.replace(/>/g,'');
    moveStr = moveStr.replace(/^x/,'');
    try {
      var destSP = moveStr.match(/^\(L?\-?\+?\d+T\-?\+?\d+\)/)[0];
      moveStr = moveStr.replace(/^\(L?\-?\+?\d+T\-?\+?\d+\)/, '');
      destSP = destSP.replace(/L/g,'');
      var destSPArr = destSP.match(/\((\-?\+?\d*)T(\-?\+?\d*)\)/);
      var destL = Number(destSPArr[1]);
      //Adjust extracted timeline if in even timeline mode
      if(isEvenTimeline) {
        if(destSPArr[1] === '-0') {
          destL = -1;
        }
        else if(destSPArr[1] === '+0') {
          destL = 1;
        }
        else if(destL < 0) {
          destL--;
        }
        else if(destL > 0) {
          destL++;
        }
      }
      var destT = Number(destSPArr[2]);
      res[1][0] = Math.abs(destL) * 2 + (destL < 0 ? -1 : 0);
      res[1][1] = (destT - 1) * 2 + (actionNum % 2 === 0 ? 0 : 1);
      if(isTurnZero) {
        res[1][1] += 2;
      }
    }
    catch(err) { throw 'Destination super-physical coordinates missing or incorrect!'; }
    var destP = this.fromSanCoord(moveStr.match(/^[a-h]\d/)[0]);
    res[1][2] = destP[0];
    res[1][3] = destP[1];
  }
  else {
    try {
      var srcSP = moveStr.match(/^\(L?\-?\+?\d+T\-?\+?\d+\)/)[0];
      moveStr = moveStr.replace(/^\(L?\-?\+?\d+T\-?\+?\d+\)/, '');
      srcSP = srcSP.replace(/L/g,'');
      var srcSPArr = srcSP.match(/\((\-?\+?\d*)T(\-?\+?\d*)\)/);
      var srcL = Number(srcSPArr[1]);
      //Adjust extracted timeline if in even timeline mode
      if(isEvenTimeline) {
        if(srcSPArr[1] === '-0') {
          srcL = -1;
        }
        else if(srcSPArr[1] === '+0') {
          srcL = 1;
        }
        else if(srcL < 0) {
          srcL--;
        }
        else if(srcL > 0) {
          srcL++;
        }
      }
      var srcT = Number(srcSPArr[2]);
      res[0][0] = Math.abs(srcL) * 2 + (srcL < 0 ? -1 : 0);
      res[0][1] = (srcT - 1) * 2 + (actionNum % 2 === 0 ? 0 : 1);
      if(isTurnZero) {
        res[0][1] += 2;
      }
    }
    catch(err) {
      if(board.length >= 1) {
        if(board[0].length > 0) {
          res[0][1] = (board[0].length - 1);
        }
      }
    }
    res[1][0] = res[0][0];
    res[1][1] = res[0][1];
    if(moveStr.includes('O-O')) {
      if(actionNum % 2 !== 0) {
        res[0][2] = 7;
        res[1][2] = 7;
      }
      else {
        res[0][2] = 0;
        res[1][2] = 0;
      }
      res[0][3] = 4;
      if(moveStr.includes('O-O-O')) {
        res[1][3] = 2;
      }
      else {
        res[1][3] = 6;
      }
    }
    else {
      var pieceChar = moveStr.match(/^[A-Z]+/);
      if(pieceChar !== null) {
        piece = pieceFuncs.fromChar(pieceChar[0], actionNum);
      }
      moveStr = moveStr.replace(/^[A-Z]+/,'');
      var coordArr = moveStr.match(/^([a-h]?\d?)x?([a-h]\d)/);
      var srcP = this.fromSanCoord(coordArr[1]);
      var destP = this.fromSanCoord(coordArr[2]);
      moveStr = moveStr.replace(/^[a-h]?\d?x?[a-h]\d/,'');
      res[0][2] = srcP[0];
      res[0][3] = srcP[1];
      res[1][2] = destP[0];
      res[1][3] = destP[1];
    }
  }

  var promotionChar = moveStr.match(/^=([A-Z])+/);
  if (promotionChar != null) {
    moveStr = moveStr.slice(promotionChar[0].length);
    res[1][4] = pieceFuncs.fromChar(promotionChar[1], actionNum);
  }

  var moves = moveGen;
  if(moves.length <= 0) {
    moves = boardFuncs.moves(board, actionNum, false, false, false, promotionPieces);
  }
  var conflictMoves = [];
  for(var i = 0;i < moves.length;i++) {
    if(
      res[0][0] === moves[i][0][0] &&
      res[0][1] === moves[i][0][1] &&
      res[1][0] === moves[i][1][0] &&
      res[1][1] === moves[i][1][1] &&
      res[1][2] === moves[i][1][2] &&
      res[1][3] === moves[i][1][3] &&
      (res[1][4] === undefined || Math.abs(res[1][4]) === Math.abs(moves[i][1][4]))
    ) {
      if(
        res[0][2] === moves[i][0][2] &&
        res[0][3] === moves[i][0][3]
      ) {
        return moves[i];
      }
      if(piece === Math.abs(board[moves[i][0][0]][moves[i][0][1]][moves[i][0][2]][moves[i][0][3]])) {
        conflictMoves.push(moves[i]);
      }
    }
  }
  var sameRank = res[0][2] < 0;
  var sameFile = res[0][3] < 0;
  for(var i = 0;i < conflictMoves.length;i++) {
    if(sameRank && sameFile) {
      //No ambiguity
      return conflictMoves[i];
    }
    else if(!sameRank && sameFile) {
      if(conflictMoves[i][0][2] === res[0][2]) {
        return conflictMoves[i];
      }
    }
    else if(sameRank && !sameFile) {
      if(conflictMoves[i][0][3] === res[0][3]) {
        return conflictMoves[i];
      }
    }
  }
  if(moves.length > 0) {
    console.error('Error occurred with this move: ' + orgMoveStr);
    console.error(res);
    throw 'No valid move found';
  }
  if(sameRank) {
    res[0][2] = 0;
  }
  if(sameFile) {
    res[0][3] = 0;
  }
  return res;
}

exports.fromAction = (action, board = [], actionNum = 0, suffix = '', timelineActivationToken = true, newTimelineToken = true, superPhysicalToken = false) => {
  var res = '';
  var tmpBoard = boardFuncs.copy(board);
  for(var i = 0;i < action.length;i++) {
    res += this.fromMove(action[i], tmpBoard, actionNum, i + 1 === action.length ? suffix : '', timelineActivationToken, newTimelineToken, superPhysicalToken);
    if(i + 1 < action.length) {
      res += ' ';
    }
    boardFuncs.move(tmpBoard, action[i]);
  }
  return res;
}

exports.toAction = (actionStr, board = [], actionNum = 0, promotionPieces = null) => {
  var tmpStr = '' + actionStr;
  tmpStr = tmpStr.replace(/\r\n/g, '\n');
  tmpStr = tmpStr.replace(/\{[^\{\}]*\}/g, '');
  tmpStr = tmpStr.replace(/;[^;\n]*\n/g, '\n');
  tmpStr = tmpStr.replace(/\(~T\-?\d*\)/g, '');
  tmpStr = tmpStr.replace(/\(>L\-?\d*\)/g, '');
  tmpStr = tmpStr.replace(/\s+/g, ' ');
  var splitArr = tmpStr.split(' ');
  var res = [];
  var tmpBoard = boardFuncs.copy(board);
  for(var i = 0;i < splitArr.length;i++) {
    if(splitArr[i].length > 0) {
      var currMove = this.toMove(splitArr[i], tmpBoard, actionNum, [], promotionPieces);
      res.push(currMove);
      boardFuncs.move(tmpBoard, currMove);
    }
  }
  return res;
}

exports.fromActionHistory = (actionHistory, startingBoard = [], startingActionNum = 0, delimiter = '\n', suffixArr = [], timelineActivationToken = true, newTimelineToken = true, superPhysicalToken = false) => {
  var tmpBoard = boardFuncs.copy(startingBoard);
  var tmpActionNum = startingActionNum;
  var res = '';
  for(var i = 0;i < actionHistory.length;i++) {
    if(tmpActionNum % 2 === 0) {
      res += (Math.floor(tmpActionNum/2) + 1) + '. ';
    }
    else {
      res += ' / ';
    }
    var currAction = this.fromAction(actionHistory[i], tmpBoard, tmpActionNum, suffixArr[i] ? suffixArr[i] : '', timelineActivationToken, newTimelineToken, superPhysicalToken);
    res += currAction;
    if(tmpActionNum % 2 !== 0 && i + 1 < actionHistory.length) {
      res += delimiter;
    }
    for(var j = 0;j < actionHistory[i].length;j++) {
      boardFuncs.move(tmpBoard, actionHistory[i][j]);
    }
    tmpActionNum++;
  }
  return res;
}

exports.toActionHistory = (actionHistoryStr, startingBoard = [], startingActionNum = 0, promotionPieces = null) => {
  var tmpBoard = boardFuncs.copy(startingBoard);
  var tmpActionNum = startingActionNum;
  var tmpStr = '' + actionHistoryStr;
  tmpStr = tmpStr.replace(/\r\n/g, '\n');
  tmpStr = tmpStr.replace(/\[[^\[\]]*\]/g, '');
  tmpStr = tmpStr.replace(/\{[^\{\}]*\}/g, '');
  tmpStr = tmpStr.replace(/;[^;\n]*\n/g, '\n');
  var splitArr = [];
  var res = [];
  var done = false;
  while(!done) {
    var match1 = tmpStr.match(/\d+\.\s*/i);
    if(match1 === null) {
      return '';
    }
    tmpStr = tmpStr.substring(match1.index + match1[0].length);
    var match2 = tmpStr.match(/\d+\.\s*/i);
    if(match2 !== null) {
      splitArr.push(tmpStr.substring(0, match2.index - 1).split('/'));
      tmpStr = tmpStr.substring(match2.index);
    }
    else {
      splitArr.push(tmpStr.split('/'));
      done = true;
    }
  }
  splitArr = splitArr.flat(1);
  for(var i = 0;i < splitArr.length;i++) {
    if (!splitArr[i].trim()) continue;
    var currAction = this.toAction(splitArr[i], tmpBoard, tmpActionNum, promotionPieces);
    res.push(currAction);
    for(var j = 0;j < currAction.length;j++) {
      boardFuncs.move(tmpBoard, currAction[j]);
    }
    tmpActionNum++;
  }
  return res;
}

},{"./board":5,"./convert":6,"./copy":7,"./parse":14,"./piece":16,"./validate":19}],16:[function(require,module,exports){
const boardFuncs = require('./board');

exports.toChar = (piece, displayPawn = false) => {
  if(displayPawn && (Math.abs(piece) === 1 || Math.abs(piece) === 2)) {
    return 'P';
  }
  if(Math.abs(piece) === 3 || Math.abs(piece) === 4) {
    return 'B';
  }
  if(Math.abs(piece) === 5 || Math.abs(piece) === 6) {
    return 'N';
  }
  if(Math.abs(piece) === 7 || Math.abs(piece) === 8) {
    return 'R';
  }
  if(Math.abs(piece) === 9 || Math.abs(piece) === 10) {
    return 'Q';
  }
  if(Math.abs(piece) === 11 || Math.abs(piece) === 12) {
    return 'K';
  }
  if(Math.abs(piece) === 13 || Math.abs(piece) === 14) {
    return 'S';
  }
  if(Math.abs(piece) === 15 || Math.abs(piece) === 16) {
    return 'W';
  }
  if(Math.abs(piece) === 17 || Math.abs(piece) === 18) {
    return 'C';
  }
  if(Math.abs(piece) === 19 || Math.abs(piece) === 20) {
    return 'Y';
  }
  if(Math.abs(piece) === 21 || Math.abs(piece) === 22) {
    return 'U';
  }
  if(Math.abs(piece) === 23 || Math.abs(piece) === 24) {
    return 'D';
  }
  return '';
}

exports.fromChar = (char, actionNum = 0) => {
  if(char === 'P') {
    return (actionNum % 2 === 0 ? 2 : 1);
  }
  if(char === 'B') {
    return (actionNum % 2 === 0 ? 4 : 3);
  }
  if(char === 'N') {
    return (actionNum % 2 === 0 ? 6 : 5);
  }
  if(char === 'R') {
    return (actionNum % 2 === 0 ? 8 : 7);
  }
  if(char === 'Q') {
    return (actionNum % 2 === 0 ? 10 : 9);
  }
  if(char === 'K') {
    return (actionNum % 2 === 0 ? 12 : 11);
  }
  if(char === 'S') {
    return (actionNum % 2 === 0 ? 14 : 13);
  }
  if(char === 'W' || char === 'BR') {
    return (actionNum % 2 === 0 ? 16 : 15);
  }
  if(char === 'C' || char === 'CK') {
    return (actionNum % 2 === 0 ? 18 : 17);
  }
  if(char === 'Y' || char === 'RQ') {
    return (actionNum % 2 === 0 ? 20 : 19);
  }
  if(char === 'U') {
    return (actionNum % 2 === 0 ? 22 : 21);
  }
  if(char === 'D') {
    return (actionNum % 2 === 0 ? 24 : 23);
  }
  return (actionNum % 2 === 0 ? 2 : 1);
}

exports.movePos = (piece) => {
  if(Math.abs(piece) === 5 || Math.abs(piece) === 6) {
    return [
      [ 0, 0, 1, 2],
      [ 0, 0, 1,-2],
      [ 0, 0,-1, 2],
      [ 0, 0,-1,-2],
      [ 0, 0, 2, 1],
      [ 0, 0, 2,-1],
      [ 0, 0,-2, 1],
      [ 0, 0,-2,-1],

      [ 0, 1, 0, 2],
      [ 0, 1, 0,-2],
      [ 0,-1, 0, 2],
      [ 0,-1, 0,-2],
      [ 0, 2, 0, 1],
      [ 0, 2, 0,-1],
      [ 0,-2, 0, 1],
      [ 0,-2, 0,-1],

      [ 0, 1, 2, 0],
      [ 0, 1,-2, 0],
      [ 0,-1, 2, 0],
      [ 0,-1,-2, 0],
      [ 0, 2, 1, 0],
      [ 0, 2,-1, 0],
      [ 0,-2, 1, 0],
      [ 0,-2,-1, 0],

      [ 1, 0, 0, 2],
      [ 1, 0, 0,-2],
      [-1, 0, 0, 2],
      [-1, 0, 0,-2],
      [ 2, 0, 0, 1],
      [ 2, 0, 0,-1],
      [-2, 0, 0, 1],
      [-2, 0, 0,-1],

      [ 1, 0, 2, 0],
      [ 1, 0,-2, 0],
      [-1, 0, 2, 0],
      [-1, 0,-2, 0],
      [ 2, 0, 1, 0],
      [ 2, 0,-1, 0],
      [-2, 0, 1, 0],
      [-2, 0,-1, 0],

      [ 1, 2, 0, 0],
      [ 1,-2, 0, 0],
      [-1, 2, 0, 0],
      [-1,-2, 0, 0],
      [ 2, 1, 0, 0],
      [ 2,-1, 0, 0],
      [-2, 1, 0, 0],
      [-2,-1, 0, 0]
    ];
  }
  if(Math.abs(piece) === 11 || Math.abs(piece) === 12 || Math.abs(piece) === 17 || Math.abs(piece) === 18) {
    return [
      [ 0, 0, 0, 1],
      [ 0, 0, 0,-1],

      [ 0, 0, 1, 0],
      [ 0, 0,-1, 0],

      [ 0, 0, 1, 1],
      [ 0, 0, 1,-1],
      [ 0, 0,-1, 1],
      [ 0, 0,-1,-1],

      [ 0, 1, 0, 0],
      [ 0,-1, 0, 0],

      [ 0, 1, 0, 1],
      [ 0, 1, 0,-1],
      [ 0,-1, 0, 1],
      [ 0,-1, 0,-1],

      [ 0, 1, 1, 0],
      [ 0, 1,-1, 0],
      [ 0,-1, 1, 0],
      [ 0,-1,-1, 0],

      [ 0, 1, 1, 1],
      [ 0, 1, 1,-1],
      [ 0, 1,-1, 1],
      [ 0, 1,-1,-1],
      [ 0,-1, 1, 1],
      [ 0,-1, 1,-1],
      [ 0,-1,-1, 1],
      [ 0,-1,-1,-1],

      [ 1, 0, 0, 0],
      [-1, 0, 0, 0],

      [ 1, 0, 0, 1],
      [ 1, 0, 0,-1],
      [-1, 0, 0, 1],
      [-1, 0, 0,-1],

      [ 1, 0, 1, 0],
      [ 1, 0,-1, 0],
      [-1, 0, 1, 0],
      [-1, 0,-1, 0],

      [ 1, 0, 1, 1],
      [ 1, 0, 1,-1],
      [ 1, 0,-1, 1],
      [ 1, 0,-1,-1],
      [-1, 0, 1, 1],
      [-1, 0, 1,-1],
      [-1, 0,-1, 1],
      [-1, 0,-1,-1],

      [ 1, 1, 0, 0],
      [ 1,-1, 0, 0],
      [-1, 1, 0, 0],
      [-1,-1, 0, 0],

      [ 1, 1, 0, 1],
      [ 1, 1, 0,-1],
      [ 1,-1, 0, 1],
      [ 1,-1, 0,-1],
      [-1, 1, 0, 1],
      [-1, 1, 0,-1],
      [-1,-1, 0, 1],
      [-1,-1, 0,-1],

      [ 1, 1, 1, 0],
      [ 1, 1,-1, 0],
      [ 1,-1, 1, 0],
      [ 1,-1,-1, 0],
      [-1, 1, 1, 0],
      [-1, 1,-1, 0],
      [-1,-1, 1, 0],
      [-1,-1,-1, 0],

      [ 1, 1, 1, 1],
      [ 1, 1, 1,-1],
      [ 1, 1,-1, 1],
      [ 1, 1,-1,-1],
      [ 1,-1, 1, 1],
      [ 1,-1, 1,-1],
      [ 1,-1,-1, 1],
      [ 1,-1,-1,-1],
      [-1, 1, 1, 1],
      [-1, 1, 1,-1],
      [-1, 1,-1, 1],
      [-1, 1,-1,-1],
      [-1,-1, 1, 1],
      [-1,-1, 1,-1],
      [-1,-1,-1, 1],
      [-1,-1,-1,-1]
    ];
  }
  return [];
}

exports.moveVecs = (piece) => {
  if(Math.abs(piece) === 3 || Math.abs(piece) === 4) {
    return [
      [ 0, 0, 1, 1],
      [ 0, 0, 1,-1],
      [ 0, 0,-1, 1],
      [ 0, 0,-1,-1],

      [ 0, 1, 0, 1],
      [ 0, 1, 0,-1],
      [ 0,-1, 0, 1],
      [ 0,-1, 0,-1],

      [ 0, 1, 1, 0],
      [ 0, 1,-1, 0],
      [ 0,-1, 1, 0],
      [ 0,-1,-1, 0],

      [ 1, 0, 0, 1],
      [ 1, 0, 0,-1],
      [-1, 0, 0, 1],
      [-1, 0, 0,-1],

      [ 1, 0, 1, 0],
      [ 1, 0,-1, 0],
      [-1, 0, 1, 0],
      [-1, 0,-1, 0],

      [ 1, 1, 0, 0],
      [ 1,-1, 0, 0],
      [-1, 1, 0, 0],
      [-1,-1, 0, 0]
    ];
  }
  if(Math.abs(piece) === 7 || Math.abs(piece) === 8) {
    return [
      [ 0, 0, 0, 1],
      [ 0, 0, 1, 0],
      [ 0, 1, 0, 0],
      [ 1, 0, 0, 0],
      [ 0, 0, 0,-1],
      [ 0, 0,-1, 0],
      [ 0,-1, 0, 0],
      [-1, 0, 0, 0]
    ];
  }
  if(Math.abs(piece) === 9 || Math.abs(piece) === 10 || Math.abs(piece) === 19 || Math.abs(piece) === 20) {
    return [
      [ 0, 0, 0, 1],
      [ 0, 0, 0,-1],

      [ 0, 0, 1, 0],
      [ 0, 0,-1, 0],

      [ 0, 0, 1, 1],
      [ 0, 0, 1,-1],
      [ 0, 0,-1, 1],
      [ 0, 0,-1,-1],

      [ 0, 1, 0, 0],
      [ 0,-1, 0, 0],

      [ 0, 1, 0, 1],
      [ 0, 1, 0,-1],
      [ 0,-1, 0, 1],
      [ 0,-1, 0,-1],

      [ 0, 1, 1, 0],
      [ 0, 1,-1, 0],
      [ 0,-1, 1, 0],
      [ 0,-1,-1, 0],

      [ 0, 1, 1, 1],
      [ 0, 1, 1,-1],
      [ 0, 1,-1, 1],
      [ 0, 1,-1,-1],
      [ 0,-1, 1, 1],
      [ 0,-1, 1,-1],
      [ 0,-1,-1, 1],
      [ 0,-1,-1,-1],

      [ 1, 0, 0, 0],
      [-1, 0, 0, 0],

      [ 1, 0, 0, 1],
      [ 1, 0, 0,-1],
      [-1, 0, 0, 1],
      [-1, 0, 0,-1],

      [ 1, 0, 1, 0],
      [ 1, 0,-1, 0],
      [-1, 0, 1, 0],
      [-1, 0,-1, 0],

      [ 1, 0, 1, 1],
      [ 1, 0, 1,-1],
      [ 1, 0,-1, 1],
      [ 1, 0,-1,-1],
      [-1, 0, 1, 1],
      [-1, 0, 1,-1],
      [-1, 0,-1, 1],
      [-1, 0,-1,-1],

      [ 1, 1, 0, 0],
      [ 1,-1, 0, 0],
      [-1, 1, 0, 0],
      [-1,-1, 0, 0],

      [ 1, 1, 0, 1],
      [ 1, 1, 0,-1],
      [ 1,-1, 0, 1],
      [ 1,-1, 0,-1],
      [-1, 1, 0, 1],
      [-1, 1, 0,-1],
      [-1,-1, 0, 1],
      [-1,-1, 0,-1],

      [ 1, 1, 1, 0],
      [ 1, 1,-1, 0],
      [ 1,-1, 1, 0],
      [ 1,-1,-1, 0],
      [-1, 1, 1, 0],
      [-1, 1,-1, 0],
      [-1,-1, 1, 0],
      [-1,-1,-1, 0],

      [ 1, 1, 1, 1],
      [ 1, 1, 1,-1],
      [ 1, 1,-1, 1],
      [ 1, 1,-1,-1],
      [ 1,-1, 1, 1],
      [ 1,-1, 1,-1],
      [ 1,-1,-1, 1],
      [ 1,-1,-1,-1],
      [-1, 1, 1, 1],
      [-1, 1, 1,-1],
      [-1, 1,-1, 1],
      [-1, 1,-1,-1],
      [-1,-1, 1, 1],
      [-1,-1, 1,-1],
      [-1,-1,-1, 1],
      [-1,-1,-1,-1]
    ];
  }
  if(Math.abs(piece) === 13 || Math.abs(piece) === 14) {
    return [
      [ 0, 0, 0, 1],
      [ 0, 0, 0,-1],

      [ 0, 0, 1, 0],
      [ 0, 0,-1, 0],

      [ 0, 0, 1, 1],
      [ 0, 0, 1,-1],
      [ 0, 0,-1, 1],
      [ 0, 0,-1,-1],

      [ 0, 1, 0, 0],
      [ 0,-1, 0, 0],

      [ 0, 1, 0, 1],
      [ 0, 1, 0,-1],
      [ 0,-1, 0, 1],
      [ 0,-1, 0,-1],

      [ 0, 1, 1, 0],
      [ 0, 1,-1, 0],
      [ 0,-1, 1, 0],
      [ 0,-1,-1, 0],

      [ 1, 0, 0, 0],
      [-1, 0, 0, 0],

      [ 1, 0, 0, 1],
      [ 1, 0, 0,-1],
      [-1, 0, 0, 1],
      [-1, 0, 0,-1],

      [ 1, 0, 1, 0],
      [ 1, 0,-1, 0],
      [-1, 0, 1, 0],
      [-1, 0,-1, 0],

      [ 1, 1, 0, 0],
      [ 1,-1, 0, 0],
      [-1, 1, 0, 0],
      [-1,-1, 0, 0]
    ];
  }
  if(Math.abs(piece) === 21 || Math.abs(piece) === 22) {
    return [
      [ 0, 1, 1, 1],
      [ 0, 1, 1,-1],
      [ 0, 1,-1, 1],
      [ 0, 1,-1,-1],
      [ 0,-1, 1, 1],
      [ 0,-1, 1,-1],
      [ 0,-1,-1, 1],
      [ 0,-1,-1,-1],

      [ 1, 0, 1, 1],
      [ 1, 0, 1,-1],
      [ 1, 0,-1, 1],
      [ 1, 0,-1,-1],
      [-1, 0, 1, 1],
      [-1, 0, 1,-1],
      [-1, 0,-1, 1],
      [-1, 0,-1,-1],

      [ 1, 1, 0, 1],
      [ 1, 1, 0,-1],
      [ 1,-1, 0, 1],
      [ 1,-1, 0,-1],
      [-1, 1, 0, 1],
      [-1, 1, 0,-1],
      [-1,-1, 0, 1],
      [-1,-1, 0,-1],

      [ 1, 1, 1, 0],
      [ 1, 1,-1, 0],
      [ 1,-1, 1, 0],
      [ 1,-1,-1, 0],
      [-1, 1, 1, 0],
      [-1, 1,-1, 0],
      [-1,-1, 1, 0],
      [-1,-1,-1, 0],
    ];
  }
  if(Math.abs(piece) === 23 || Math.abs(piece) === 24) {
    return [
      [ 1, 1, 1, 1],
      [ 1, 1, 1,-1],
      [ 1, 1,-1, 1],
      [ 1, 1,-1,-1],
      [ 1,-1, 1, 1],
      [ 1,-1, 1,-1],
      [ 1,-1,-1, 1],
      [ 1,-1,-1,-1],
      [-1, 1, 1, 1],
      [-1, 1, 1,-1],
      [-1, 1,-1, 1],
      [-1, 1,-1,-1],
      [-1,-1, 1, 1],
      [-1,-1, 1,-1],
      [-1,-1,-1, 1],
      [-1,-1,-1,-1]
    ];
  }
  return [];
}

exports.availablePromotionPieces = (board) => {
  var res = [];
  for(var l = 0;board && l < board.length;l++) {
    for(var t = 0;board[l] && t < board[l].length;t++) {
      for(var r = 0;board[l][t] && r < board[l][t].length;r++) {
        for(var f = 0;board[l][t][r] && f < board[l][t][r].length;f++) {
          var piece = Math.abs(board[l][t][r][f]);
          if(!res.includes(piece)) {
            if(
              piece >= 3 && piece <= 10 ||
              piece >= 13 && piece <= 14 ||
              piece >= 17 && piece <= 18
            ) {
              res.push(piece);
            }
          }
        }
      }
    }
  }
  //Order pieces in order of importance
  //TODO: system to modify this.promotionPieces on index.js for builtin variants that need it
  return res.sort((a, b) => b - a);
}

exports.timelineMove = (sourceTimelineIndex, timelineMoveVector, isEvenTimeline = false) => {
  var ret = 0;
  if(sourceTimelineIndex % 2 === 0) {
    ret = sourceTimelineIndex + (timelineMoveVector * 2);
  }
  else {
    ret = sourceTimelineIndex - (timelineMoveVector * 2);
  }
  if(!isEvenTimeline && ret < 0) {
    ret = (ret * -1) - 1;
  }
  if(isEvenTimeline && ret <= 0) {
    ret = (ret * -1) + 1;
  }
  return ret;
}

exports.moves = (board, src, spatialOnly = false, promotionPieces = null) => {
  var res = [];
  var isEvenTimeline = boardFuncs.isEvenTimeline(board);
  if(boardFuncs.positionExists(board, src)) {
    var piece = board[src[0]][src[1]][src[2]][src[3]];
    if(Math.abs(piece) === 0) { return []; }
    //Single square moves
    var movePos = this.movePos(piece);
    for(var i = 0;i < movePos.length;i++) {
      if(!spatialOnly || (spatialOnly && (movePos[i][0] === 0 && movePos[i][1] === 0))) {
        var currMove = [src.slice(), src.slice()];
        currMove[1][0] = this.timelineMove(currMove[1][0], movePos[i][0], isEvenTimeline);
        currMove[1][1] += movePos[i][1] * 2;
        currMove[1][2] += movePos[i][2];
        currMove[1][3] += movePos[i][3];
        if(boardFuncs.positionExists(board, currMove[1])) {
          var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
          if(destPiece === 0 || (Math.abs(destPiece) % 2 !== Math.abs(piece) % 2)) {
            res.push(currMove);
          }
        }
      }
    }
    //Vector moves
    var moveVecs = this.moveVecs(piece);
    for(var i = 0;i < moveVecs.length;i++) {
      if(!spatialOnly || (spatialOnly && (moveVecs[i][0] === 0 && moveVecs[i][1] === 0))) {
        var currMove = [src.slice(), src.slice()];
        var blocking = false;
        while(!blocking) {
          currMove[1][0] = this.timelineMove(currMove[1][0], moveVecs[i][0], isEvenTimeline);
          currMove[1][1] += moveVecs[i][1] * 2;
          currMove[1][2] += moveVecs[i][2];
          currMove[1][3] += moveVecs[i][3];
          if(boardFuncs.positionExists(board, currMove[1])) {
            var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
            if(destPiece === 0 || (Math.abs(destPiece) % 2 !== Math.abs(piece) % 2)) {
              res.push([currMove[0].slice(),currMove[1].slice()]);
              if(Math.abs(destPiece) % 2 !== Math.abs(piece) % 2 && destPiece !== 0) { blocking = true; }
            }
            else { blocking = true; }
          }
          else { blocking = true; }
        }
      }
    }
    //Black pawn/brawn moves
    if(Math.abs(piece) === 1 || Math.abs(piece) === 15) {
      //Black forward single square RF movement
      var currMove = [src.slice(), src.slice()];
      currMove[1][2]--;
      if(boardFuncs.positionExists(board, currMove[1])) {
        var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
        if(destPiece === 0) {
          if(currMove[1][2] === 0) {
            if(!promotionPieces || promotionPieces.length <= 0) {
              promotionPieces = this.availablePromotionPieces(board);
            }
            for(var i = 0;i < promotionPieces.length;i++) {
              if(promotionPieces[i] % 2 === Math.abs(piece) % 2) {
                currMove[1][4] = promotionPieces[i];
                res.push([currMove[0].slice(), currMove[1].slice()]);
              }
            }
          }
          else {
            res.push([currMove[0].slice(), currMove[1].slice()]);
          }
        }
      }
      //Black forward single square capture RF movement
      currMove = [src.slice(), src.slice()];
      currMove[1][2]--;
      currMove[1][3]++;
      if(boardFuncs.positionExists(board, currMove[1])) {
        var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
        if(destPiece !== 0 && (Math.abs(destPiece) % 2 !== Math.abs(piece) % 2)) {
          if(currMove[1][2] === 0) {
            if(!promotionPieces || promotionPieces.length <= 0) {
              promotionPieces = this.availablePromotionPieces(board);
            }
            for(var i = 0;i < promotionPieces.length;i++) {
              if(promotionPieces[i] % 2 === Math.abs(piece) % 2) {
                currMove[1][4] = promotionPieces[i];
                res.push([currMove[0].slice(), currMove[1].slice()]);
              }
            }
          }
          else {
            res.push([currMove[0].slice(), currMove[1].slice()]);
          }
        }
      }
      currMove = [src.slice(), src.slice()];
      currMove[1][2]--;
      currMove[1][3]--;
      if(boardFuncs.positionExists(board, currMove[1])) {
        var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
        if(destPiece !== 0 && (Math.abs(destPiece) % 2 !== Math.abs(piece) % 2)) {
          if(currMove[1][2] === 0) {
            if(!promotionPieces || promotionPieces.length <= 0) {
              promotionPieces = this.availablePromotionPieces(board);
            }
            for(var i = 0;i < promotionPieces.length;i++) {
              if(promotionPieces[i] % 2 === Math.abs(piece) % 2) {
                currMove[1][4] = promotionPieces[i];
                res.push([currMove[0].slice(), currMove[1].slice()]);
              }
            }
          }
          else {
            res.push([currMove[0].slice(), currMove[1].slice()]);
          }
        }
      }
      //Black forward en passant capture RF movement
      currMove = [src.slice(), src.slice()];
      currMove[1][2]--;
      currMove[1][3]++;
      if(boardFuncs.positionExists(board, [
        currMove[1][0],
        currMove[1][1],
        currMove[1][2]+1,
        currMove[1][3]
      ])) {
        var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]+1][currMove[1][3]];
        if(destPiece === 2 || destPiece === 16) {
          if(boardFuncs.positionExists(board, [
            currMove[1][0],
            currMove[1][1]-2,
            currMove[1][2]-1,
            currMove[1][3]
          ])) {
            var destPiece = board[currMove[1][0]][currMove[1][1]-2][currMove[1][2]-1][currMove[1][3]];
            if(destPiece === -2 || destPiece === -16) {
              res.push([currMove[0].slice(), currMove[1].slice(), [
                currMove[1][0],
                currMove[1][1],
                currMove[1][2]+1,
                currMove[1][3]
              ]]);
            }
          }
        }
      }
      currMove = [src.slice(), src.slice()];
      currMove[1][2]--;
      currMove[1][3]--;
      if(boardFuncs.positionExists(board, [
        currMove[1][0],
        currMove[1][1],
        currMove[1][2]+1,
        currMove[1][3]
      ])) {
        var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]+1][currMove[1][3]];
        if(destPiece === 2 || destPiece === 16) {
          if(boardFuncs.positionExists(board, [
            currMove[1][0],
            currMove[1][1]-2,
            currMove[1][2]-1,
            currMove[1][3]
          ])) {
            var destPiece = board[currMove[1][0]][currMove[1][1]-2][currMove[1][2]-1][currMove[1][3]];
            if(destPiece === -2 || destPiece === -16) {
              res.push([currMove[0].slice(), currMove[1].slice(), [
                currMove[1][0],
                currMove[1][1],
                currMove[1][2]+1,
                currMove[1][3]
              ]]);
            }
          }
        }
      }
      //Black forward double square RF movement
      if(piece === -1 || piece === -15) {
        currMove = [src.slice(), src.slice()];
        currMove[1][2] -= 2;
        if(boardFuncs.positionExists(board, currMove[1])) {
          var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
          if(destPiece === 0) {
            destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]+1][currMove[1][3]];
            if(destPiece === 0) {
              if(currMove[1][2] === 0) {
                if(!promotionPieces || promotionPieces.length <= 0) {
                  promotionPieces = this.availablePromotionPieces(board);
                }
                for(var i = 0;i < promotionPieces.length;i++) {
                  if(promotionPieces[i] % 2 === Math.abs(piece) % 2) {
                    currMove[1][4] = promotionPieces[i];
                    res.push([currMove[0].slice(), currMove[1].slice()]);
                  }
                }
              }
              else {
                res.push([currMove[0].slice(), currMove[1].slice()]);
              }
            }
          }
        }
      }
      if(!spatialOnly) {
        //Black forward single square LT movement
        currMove = [src.slice(), src.slice()];
        currMove[1][0] = this.timelineMove(currMove[1][0], 1, isEvenTimeline);
        if(boardFuncs.positionExists(board, currMove[1])) {
          var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
          if(destPiece === 0) {
            res.push([currMove[0].slice(), currMove[1].slice()]);
            //Black forward double square LT movement
            if(piece === -1 || piece === -15) {
              currMove = [src.slice(), src.slice()];
              currMove[1][0] = this.timelineMove(currMove[1][0], 2, isEvenTimeline);
              if(boardFuncs.positionExists(board, currMove[1])) {
                var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
                if(destPiece === 0) {
                  res.push([currMove[0].slice(), currMove[1].slice()]);
                }
              }
            }
          }
        }
        //Black forward single square capture LT movement
        currMove = [src.slice(), src.slice()];
        currMove[1][0] = this.timelineMove(currMove[1][0], 1, isEvenTimeline);
        currMove[1][1] += 2;
        if(boardFuncs.positionExists(board, currMove[1])) {
          var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
          if(destPiece !== 0 && (Math.abs(destPiece) % 2 !== Math.abs(piece) % 2)) {
            res.push([currMove[0].slice(), currMove[1].slice()]);
          }
        }
        currMove = [src.slice(), src.slice()];
        currMove[1][0] = this.timelineMove(currMove[1][0], 1, isEvenTimeline);
        currMove[1][1] -= 2;
        if(boardFuncs.positionExists(board, currMove[1])) {
          var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
          if(destPiece !== 0 && (Math.abs(destPiece) % 2 !== Math.abs(piece) % 2)) {
            res.push([currMove[0].slice(), currMove[1].slice()]);
          }
        }
      }
    }
    //White pawn/brawn moves
    if(Math.abs(piece) === 2 || Math.abs(piece) === 16) {
      //White forward single square RF movement
      var currMove = [src.slice(), src.slice()];
      currMove[1][2]++;
      if(boardFuncs.positionExists(board, currMove[1])) {
        var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
        if(destPiece === 0) {
          if(currMove[1][2] === (board[currMove[0][0]][currMove[0][1]].length - 1)) {
            if(!promotionPieces || promotionPieces.length <= 0) {
              promotionPieces = this.availablePromotionPieces(board);
            }
            for(var i = 0;i < promotionPieces.length;i++) {
              if(promotionPieces[i] % 2 === Math.abs(piece) % 2) {
                currMove[1][4] = promotionPieces[i];
                res.push([currMove[0].slice(), currMove[1].slice()]);
              }
            }
          }
          else {
            res.push([currMove[0].slice(), currMove[1].slice()]);
          }
        }
      }
      //White forward single square capture RF movement
      currMove = [src.slice(), src.slice()];
      currMove[1][2]++;
      currMove[1][3]++;
      if(boardFuncs.positionExists(board, currMove[1])) {
        var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
        if(destPiece !== 0 && (Math.abs(destPiece) % 2 !== Math.abs(piece) % 2)) {
          if(currMove[1][2] === (board[currMove[0][0]][currMove[0][1]].length - 1)) {
            if(!promotionPieces || promotionPieces.length <= 0) {
              promotionPieces = this.availablePromotionPieces(board);
            }
            for(var i = 0;i < promotionPieces.length;i++) {
              if(promotionPieces[i] % 2 === Math.abs(piece) % 2) {
                currMove[1][4] = promotionPieces[i];
                res.push([currMove[0].slice(), currMove[1].slice()]);
              }
            }
          }
          else {
            res.push([currMove[0].slice(), currMove[1].slice()]);
          }
        }
      }
      currMove = [src.slice(), src.slice()];
      currMove[1][2]++;
      currMove[1][3]--;
      if(boardFuncs.positionExists(board, currMove[1])) {
        var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
        if(destPiece !== 0 && (Math.abs(destPiece) % 2 !== Math.abs(piece) % 2)) {
          if(currMove[1][2] === (board[currMove[0][0]][currMove[0][1]].length - 1)) {
            if(!promotionPieces || promotionPieces.length <= 0) {
              promotionPieces = this.availablePromotionPieces(board);
            }
            for(var i = 0;i < promotionPieces.length;i++) {
              if(promotionPieces[i] % 2 === Math.abs(piece) % 2) {
                currMove[1][4] = promotionPieces[i];
                res.push([currMove[0].slice(), currMove[1].slice()]);
              }
            }
          }
          else {
            res.push([currMove[0].slice(), currMove[1].slice()]);
          }
        }
      }
      //White forward en passant capture RF movement
      currMove = [src.slice(), src.slice()];
      currMove[1][2]++;
      currMove[1][3]++;
      if(boardFuncs.positionExists(board, [
        currMove[1][0],
        currMove[1][1],
        currMove[1][2]-1,
        currMove[1][3]
      ])) {
        var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]-1][currMove[1][3]];
        if(destPiece === 1 || destPiece === 15) {
          if(boardFuncs.positionExists(board, [
            currMove[1][0],
            currMove[1][1]-2,
            currMove[1][2]+1,
            currMove[1][3]
          ])) {
            var destPiece = board[currMove[1][0]][currMove[1][1]-2][currMove[1][2]+1][currMove[1][3]];
            if(destPiece === -1 || destPiece === -15) {
              res.push([currMove[0].slice(), currMove[1].slice(), [
                currMove[1][0],
                currMove[1][1],
                currMove[1][2]-1,
                currMove[1][3]
              ]]);
            }
          }
        }
      }
      currMove = [src.slice(), src.slice()];
      currMove[1][2]++;
      currMove[1][3]--;
      if(boardFuncs.positionExists(board, [
        currMove[1][0],
        currMove[1][1],
        currMove[1][2]-1,
        currMove[1][3]
      ])) {
        var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]-1][currMove[1][3]];
        if(destPiece === 1 || destPiece === 15) {
          if(boardFuncs.positionExists(board, [
            currMove[1][0],
            currMove[1][1]-2,
            currMove[1][2]+1,
            currMove[1][3]
          ])) {
            var destPiece = board[currMove[1][0]][currMove[1][1]-2][currMove[1][2]+1][currMove[1][3]];
            if(destPiece === -1 || destPiece === -15) {
              res.push([currMove[0].slice(), currMove[1].slice(), [
                currMove[1][0],
                currMove[1][1],
                currMove[1][2]-1,
                currMove[1][3]
              ]]);
            }
          }
        }
      }
      //White forward double square RF movement
      if(piece === -2 || piece === -16) {
        currMove = [src.slice(), src.slice()];
        currMove[1][2] += 2;
        if(boardFuncs.positionExists(board, currMove[1])) {
          var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
          if(destPiece === 0) {
            destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]-1][currMove[1][3]];
            if(destPiece === 0) {
              if(currMove[1][2] === (board[currMove[0][0]][currMove[0][1]].length - 1)) {
                if(!promotionPieces || promotionPieces.length <= 0) {
                  promotionPieces = this.availablePromotionPieces(board);
                }
                for(var i = 0;i < promotionPieces.length;i++) {
                  if(promotionPieces[i] % 2 === Math.abs(piece) % 2) {
                    currMove[1][4] = promotionPieces[i];
                    res.push([currMove[0].slice(), currMove[1].slice()]);
                  }
                }
              }
              else {
                res.push([currMove[0].slice(), currMove[1].slice()]);
              }
            }
          }
        }
      }
      if(!spatialOnly) {
        //White forward single square LT movement
        currMove = [src.slice(), src.slice()];
        currMove[1][0] = this.timelineMove(currMove[1][0], -1, isEvenTimeline);
        if(boardFuncs.positionExists(board, currMove[1])) {
          var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
          if(destPiece === 0) {
            res.push([currMove[0].slice(), currMove[1].slice()]);
            //White forward double square LT movement
            if(piece === -1 || piece === -15) {
              currMove = [src.slice(), src.slice()];
              currMove[1][0] = this.timelineMove(currMove[1][0], -2, isEvenTimeline);
              if(boardFuncs.positionExists(board, currMove[1])) {
                var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
                if(destPiece === 0) {
                  res.push([currMove[0].slice(), currMove[1].slice()]);
                }
              }
            }
          }
        }
        //White forward single square capture LT movement
        currMove = [src.slice(), src.slice()];
        currMove[1][0] = this.timelineMove(currMove[1][0], -1, isEvenTimeline);
        currMove[1][1] += 2;
        if(boardFuncs.positionExists(board, currMove[1])) {
          var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
          if(destPiece !== 0 && (Math.abs(destPiece) % 2 !== Math.abs(piece) % 2)) {
            res.push([currMove[0].slice(), currMove[1].slice()]);
          }
        }
        currMove = [src.slice(), src.slice()];
        currMove[1][0] = this.timelineMove(currMove[1][0], -1, isEvenTimeline);
        currMove[1][1] -= 2;
        if(boardFuncs.positionExists(board, currMove[1])) {
          var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
          if(destPiece !== 0 && (Math.abs(destPiece) % 2 !== Math.abs(piece) % 2)) {
            res.push([currMove[0].slice(), currMove[1].slice()]);
          }
        }
      }
    }
    // Brawn-specific captures
    if (Math.abs(piece) === 15 || Math.abs(piece) === 16) {
      let promotionRank = Math.abs(piece) % 2 === 0 ? board[src[0]][src[1]].length - 1 : 0;
      let forward = Math.abs(piece) % 2 === 0 ? 1 : -1;
      // l, t, y, x
      let cardinalities = [
        [-forward, 0, 0, 1],
        [-forward, 0, 0, -1],
        [-forward, 0, forward, 0],
        [0, -1, forward, 0],
      ];

      for (let [dl, dt, dy, dx] of cardinalities) {
        if (src[0] % 2 === 0) {
          // White's timelines
          currMove = [src.slice(), [
            src[0],
            src[1] + 2 * dt,
            src[2] + dy,
            src[3] + dx
          ]];
          currMove[1][0] = this.timelineMove(currMove[1][0], dl, isEvenTimeline);
        } else {
          // Black's timelines
          currMove = [src.slice(), [
            src[0],
            src[1] + 2 * dt,
            src[2] + dy,
            src[3] + dx
          ]];
          currMove[1][0] = this.timelineMove(currMove[1][0], dl, isEvenTimeline);
        }

        // Verify the capture and yield the move
        if(boardFuncs.positionExists(board, currMove[1])) {
          var destPiece = board[currMove[1][0]][currMove[1][1]][currMove[1][2]][currMove[1][3]];
          if(destPiece !== 0 && (Math.abs(destPiece) % 2 !== Math.abs(piece) % 2)) {

            if(currMove[1][2] === promotionRank) {
              // Must promote
              if(!promotionPieces || promotionPieces.length <= 0) {
                promotionPieces = this.availablePromotionPieces(board);
              }
              for(var i = 0;i < promotionPieces.length;i++) {
                if(promotionPieces[i] % 2 === Math.abs(piece) % 2) {
                  currMove[1][4] = promotionPieces[i];
                  res.push([currMove[0].slice(), currMove[1].slice()]);
                }
              }
            }
            else {
              // Can't promote
              res.push([currMove[0].slice(), currMove[1].slice()]);
            }
          }
        }
      }
    }
    //Castling
    //TODO: Fix and reformat castling to be flexible
    if(piece === -11 || piece === -12) {
      //Queenside Castling Movement
      if(!boardFuncs.positionIsAttacked(board, src, Math.abs(piece) % 2)) {
        var leftOnePos = [
          src[0],
          src[1],
          src[2],
          src[3] - 1,
        ];
        if(
          boardFuncs.positionExists(board, leftOnePos) &&
          board[leftOnePos[0]][leftOnePos[1]][leftOnePos[2]][leftOnePos[3]] === 0 &&
          !boardFuncs.positionIsAttacked(board, leftOnePos, Math.abs(piece) % 2)
        ) {
          var leftTwoPos = [
            src[0],
            src[1],
            src[2],
            src[3] - 2,
          ];
          if(
            boardFuncs.positionExists(board, leftTwoPos) &&
            board[leftTwoPos[0]][leftTwoPos[1]][leftTwoPos[2]][leftTwoPos[3]] === 0 &&
            !boardFuncs.positionIsAttacked(board, leftTwoPos, Math.abs(piece) % 2)
          ) {
            //Search left for rook
            var done = false;
            var currPos = leftTwoPos.slice();
            currPos[3]--;
            while(!done) {
              if(boardFuncs.positionExists(board, currPos)) {
                var currPiece = board[currPos[0]][currPos[1]][currPos[2]][currPos[3]];
                if(currPiece === -7 || currPiece === -8) {
                  if(Math.abs(piece) % 2 === Math.abs(currPiece) % 2) {
                    res.push([
                      src.slice(),
                      leftTwoPos.slice(),
                      currPos.slice(),
                      leftOnePos.slice()
                    ]);
                  }
                }
                else if(currPiece !== 0) {
                  done = true;
                }
              }
              else {
                done = true;
              }
              currPos[3]--;
            }
          }
        }
      }
      //Kingside Castling Movement
      if(!boardFuncs.positionIsAttacked(board, src, Math.abs(piece) % 2)) {
        var rightOnePos = [
          src[0],
          src[1],
          src[2],
          src[3] + 1,
        ];
        if(
          boardFuncs.positionExists(board, rightOnePos) &&
          board[rightOnePos[0]][rightOnePos[1]][rightOnePos[2]][rightOnePos[3]] === 0 &&
          !boardFuncs.positionIsAttacked(board, rightOnePos, Math.abs(piece) % 2)
        ) {
          var rightTwoPos = [
            src[0],
            src[1],
            src[2],
            src[3] + 2,
          ];
          if(
            boardFuncs.positionExists(board, rightTwoPos) &&
            board[rightTwoPos[0]][rightTwoPos[1]][rightTwoPos[2]][rightTwoPos[3]] === 0 &&
            !boardFuncs.positionIsAttacked(board, rightTwoPos, Math.abs(piece) % 2)
          ) {
            //Search right for rook
            var done = false;
            var currPos = rightTwoPos.slice();
            currPos[3]++;
            while(!done) {
              if(boardFuncs.positionExists(board, currPos)) {
                var currPiece = board[currPos[0]][currPos[1]][currPos[2]][currPos[3]];
                if(currPiece === -7 || currPiece === -8) {
                  if(Math.abs(piece) % 2 === Math.abs(currPiece) % 2) {
                    res.push([
                      src.slice(),
                      rightTwoPos.slice(),
                      currPos.slice(),
                      rightOnePos.slice()
                    ]);
                  }
                }
                else if(currPiece !== 0) {
                  done = true;
                }
              }
              else {
                done = true;
              }
              currPos[3]++;
            }
          }
        }
      }
    }
  }
  return res;
}

},{"./board":5}],17:[function(require,module,exports){
exports.turnArray = (board, timeline, turn) => {
  var res = [];
  for(var r = 0;r < 10;r++) {
    res[r] = [];
    for(var f = 0;f < 10;f++) {
      if(r === 0) {
        if(f === 0) {
          res[r][f] = (turn % 2 === 0 ? '' + '' : '');
        }
        else if(f === 9) {
          res[r][f] = (turn % 2 === 0 ? '' + '' : '');
        }
        else {
          res[r][f] = (turn % 2 === 0 ? '' + '' : '');
        }
      }
      else if(r === 9) {
        if(f === 0) {
          res[r][f] = (turn % 2 === 0 ? '' + '' : '');
        }
        else if(f === 9) {
          res[r][f] = (turn % 2 === 0 ? '' + '' : '');
        }
        else {
          res[r][f] = (turn % 2 === 0 ? '' + '' : '');
        }
      }
      else if(f === 0) {
        res[r][f] = (turn % 2 === 0 ? '' + '' : '');
      }
      else if(f === 9) {
        res[r][f] = (turn % 2 === 0 ? '' + '' : '');
      }
      else {
        res[r][f] = '.';
      }
    }
  }
  if(board && board[timeline] && board[timeline][turn]) {
    for(var r = 0;r < board[timeline][turn].length;r++) {
      if(board[timeline][turn][r]) {
        for(var f = 0;f < board[timeline][turn][r].length;f++) {
          var piece = Math.abs(board[timeline][turn][r][f]);
          if(piece === 1) {
            res[8 - r][f + 1] = 'p';
          }
          else if(piece === 3) {
            res[8 - r][f + 1] = 'b';
          }
          else if(piece === 5) {
            res[8 - r][f + 1] = 'n';
          }
          else if(piece === 7) {
            res[8 - r][f + 1] = 'r';
          }
          else if(piece === 9) {
            res[8 - r][f + 1] = 'q';
          }
          else if(piece === 11) {
            res[8 - r][f + 1] = 'k';
          }
          else if(piece === 13) {
            res[8 - r][f + 1] = 's';
          }
          else if(piece === 2) {
            res[8 - r][f + 1] = 'P';
          }
          else if(piece === 4) {
            res[8 - r][f + 1] = 'B';
          }
          else if(piece === 6) {
            res[8 - r][f + 1] = 'N';
          }
          else if(piece === 8) {
            res[8 - r][f + 1] = 'R';
          }
          else if(piece === 10) {
            res[8 - r][f + 1] = 'Q';
          }
          else if(piece === 12) {
            res[8 - r][f + 1] = 'K';
          }
          else if(piece === 14) {
            res[8 - r][f + 1] = 'S';
          }
        }
      }
    }
  }
  var string = '' + timeline + ',' + turn;
  for(var i = 1;i < 10;i++) {
    if(i-1 < string.length) {
      res[0][i] = string.charAt(i-1);
    }
  }
  for(var r = 1;r < 9;r++) {
    for(var f = 1;f < 9;f++) {
      if((r + f) % 2 === 0) {
        res[r][f] = res[r][f];
      }
    }
  }
  return res;
}

exports.blankTurnArray = () => {
  var res = [];
  for(var r = 0;r < 10;r++) {
    res[r] = [];
    for(var f = 0;f < 10;f++) {
      res[r][f] = ' ';
    }
  }
  return res;
}

exports.boardArray = (board) => {
  var res = [];
  var offset = 0;
  for(var l = board.length - 1;board && l >= 0;l--) {
    if(l % 2 !== 0) {
      res[Math.floor((board.length - l - 1)/2)] = [];
      offset++;
    }
    if(Array.isArray(board[l]) && l % 2 !== 0) {
      for(var t = 0;t < board[l].length;t++) {
        if(Array.isArray(board[l][t])) {
          res[Math.floor((board.length - l - 1)/2)][t] = this.turnArray(board, l, t);
        }
        else {
          res[Math.floor((board.length - l - 1)/2)][t] = this.blankTurnArray(board, l, t);
        }
      }
    }
  }
  for(var l = 0;board && l < board.length;l++) {
    if(Array.isArray(board[l]) && l % 2 === 0) {
      res[l/2 + offset] = [];
      for(var t = 0;t < board[l].length;t++) {
        if(Array.isArray(board[l][t])) {
          res[l/2 + offset][t] = this.turnArray(board, l, t);
        }
        else {
          res[l/2 + offset][t] = this.blankTurnArray(board, l, t);
        }
      }
    }
  }
  return res;
}

exports.printBoard = (board) => {
  var printStr = '';
  var array = this.boardArray(board);
  for(var l = 0;array && l < array.length;l++) {
    for(var r = 0;r < 10;r++) {
      for(var t = 0;array[l] && t < array[l].length;t++) {
        for(var f = 0;f < 10;f++) {
          printStr += array[l][t][r][f];
        }
      }
      printStr += '\n';
    }
  }
  return printStr;
}

},{}],18:[function(require,module,exports){
exports.copy = (board, timeline, turn) => {
  var res = [];
  if(board && board[timeline] && board[timeline][turn]) {
    for(var r = 0;r < board[timeline][turn].length;r++) {
      if(board[timeline][turn][r]) {
        res.push(board[timeline][turn][r].slice());
      }
    }
  }
  if(res.length <= 0) {
    return null;
  }
  return res;
}

},{}],19:[function(require,module,exports){
const boardFuncs = require('./board');

exports.move = (board, actionNum, move, moveGen = [], promotionPieces = null) => {
  if(moveGen.length <= 0) {
    moveGen = boardFuncs.moves(board, actionNum, false, false, false, promotionPieces);
  }
  for(var i = 0;i < moveGen.length;i++) {
    if(this.compareMove(moveGen[i], move) === 0) { return true; }
  }
  return false;
}

exports.action = (board, actionNum, moves, variant = 'standard') => {
  var newBoard = boardFuncs.copy(board);
  for(var i = 0;i < moves.length;i++) {
    if(!this.move(newBoard, actionNum, moves[i], variant)) { return false; }
    boardFuncs.move(newBoard, moves[i]);
  }
  if(boardFuncs.present(newBoard, actionNum).length > 0) {
    return false;
  }
  return true;
}

exports.notation = (notation) => {
  var regexRegular = notation.match(/^(\d+[bw]\.\s)\d+([\-\+]\d+)?:[PBNRQK]?[a-h][1-8]((<([\-\+]\d+)?>)+\d*([\-\+]\d+)?)?:x?[PBNRQ]?[a-h][1-8](e\.p\.)?[\=\+\#]?/);
  var regexCastling = notation.match(/^(\d+[bw]\.\s)\d+([\-\+]\d+)?:0\-0(\-0)?[\=\+\#]?/);
  if(regexRegular === null && regexCastling === null) { return false; }
  if(
    (regexRegular !== null && regexRegular[0] !== notation) ||
    (regexCastling !== null && regexCastling[0] !== notation)
  ) { return false; }
  return true;
}

exports.compareMove = (move1, move2) => {
  if(Array.isArray(move1)) {
    if(Array.isArray(move2)) {
      if(move1.length === move2.length) {
        for(var i = 0;i < move1.length;i++) {
          for(var j = 0;j < move1[i].length;j++) {
            if(move1[i].length !== move2[i].length) {
              return move1[i].length - move2[i].length;
            }
            if(move1[i][j] !== move2[i][j]) {
              if(move1[i][j] === undefined) {
                return -1;
              }
              if(move2[i][j] === undefined) {
                return 1;
              }
              return move1[i][j] - move2[i][j];
            }
          }
        }
      }
      else {
        return move1.length - move2.length;
      }
    }
    else {
      return -1;
    }
  }
  else {
    if(Array.isArray(move2)) {
      return 1;
    }
    else {
      return 0;
    }
  }
  return 0;
}

},{"./board":5}]},{},[10])(10)
});
